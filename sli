#!/bin/bash
#
# Simply Lightning - A versatile shell utility that simplifies Bitcoin
# Lightning Network packages management while offering a suite of handy
# tools for seamless node operations.
#
# (c) 2025 0xeeLi ‚ö°Ô∏è MIT License
#
sli_version="v0.2.0"

# --- Default Lightning paths ---

LIT_DIR="$HOME/.lit"
LIT_CONF="$LIT_DIR/lit.conf"
LND_DIR="$HOME/.lnd"
LND_CONF="$LND_DIR/lnd.conf"
ALBY_CONF="/etc/systemd/system/albyhub.service" # Use Environment=

# --- Configurable Variables - Can be in a custom sli.conf ---

SLI_DIR="$HOME/.sli"
SLI_CONF="$SLI_DIR/sli.conf"
WALLET_PASS="$LND_DIR/wallet.pass"
BACKUP_DIR="$HOME/sli-backups"
INVOICE_DIR="$HOME/sli-invoice"
EDITOR="nano"

# Load optional custom SLi config file
[ -f "$SLI_CONF" ] && source ${SLI_CONF}

# --- Global Variables ---

INSTALLED_PKGS=${SLI_DIR}/packages
CACHE_DIR=${SLI_DIR}/cache
PKGS_LIST=${SLI_DIR}/packages.list
PKGS_RECIPES=${SLI_DIR}/recipes
PKGS_RECIPES_SUM=${SLI_DIR}/recipes.sha512
PKGS_RECIPES_URL="https://raw.githubusercontent.com/0xeeli/sli/main/recipes"
PKGS_URL="https://raw.githubusercontent.com/0xeeli/sli/main/packages.list"
AMBOSS_API="https://api.amboss.space/graphql"
WALLET_DB="$LND_DIR/data/chain/bitcoin/mainnet/wallet.db"

# Log files for SLi Wallet and Node actions
SLI_LOG=${SLI_DIR}/sli.log

# Node Backup
TMP_BACKUP_DIR="$BACKUP_DIR/tmp"
EXTRACTED_DIR="$BACKUP_DIR/extracted"

# Colors
PURPLE='\033[1;35m'
CYAN='\033[1;36m'
YELLOW='\033[1;33m'
RED='\033[1;31m'
GREEN='\033[1;32m'
NC='\033[0m' # No color

# Emoji: üîå ‚ö°Ô∏è ‚úò üîí üí∞ üîó

#
# --- Helper Functions ---
#

# Display usage instructions (ident with space)
usage() {
	cat << EOT
Usage: $(basename $0) [command|tool] [pkg|arg] [arg]
$(print_separator)
$(echo -e "${YELLOW}Commands:${NC}")
  init               Initialize a service, tool or package
  start              Start a service
  stop               Stop a service
  rs|restart         Restart a service
  sc|show-config     Display config file
  ed|edit            Edit a config file
  lg|logs            Show last logs for a service (default: 30 lines)
  st|status          Show service status

$(echo -e "${YELLOW}Node Manager:${NC}")
  nh|node-health     Node Health report
  sign               Sign message with your node private key
  connect            Connect to a remote peer
  disconnect         Disconnect a remote peer
  peers              List all connected peers
  chan               Channel management (open, close, list)
  fees               Fee management (check, set, adjust, bump)

$(echo -e "${YELLOW}Tools:${NC}")
  m2h|macaroon-hex   Get the HEX format of a macaroon
  gpw|gen-passwords  Gen new passwords for the wallet and Lit UI
  nb|node-backup     Backup and encrypt your node (wallet include)
  nr|node-restore    Restore a GPG encrypted backup file
  ne|node-extract    Extract a GPG encrypted backup file
  sec|security-check Check files permissions created by SLi
  ping-amboss        Ping Amboss Health Check API
  wa|wallet          Run 'sli wa' for wallet operations

$(echo -e "${YELLOW}Packages Manager:${NC}")
  ls|list            List installed and available packages
  in|install         Install a package
  up|upgrade         Upgrade installed packages
  gr|get-recipe      Get latest package recipe from GitHub
  cc|clean-cache     Remove downloaded packages tarball
  rm|remove          Remove a package
EOT
}

# Wallet usage
wallet_usage() {
	cat << EOT
Usage: $(basename $0) [wa|wallet] [command]
$(print_separator)
  init                Initialize the wallet if none exists
  logs                View Wallet logs
  new                 Create a ‚ÇøTC onchain address
  send                Send ‚ÇøTC onchain
  lsa|list-addresses  List onchain wallet addresses
  bal|balance         Wallet balance
  inv|invoice         Generate a Lightning invoice
  qri|qr-invoice      Generate a Lightning QR invoice
  rqr|remove-qr       Remove latest QR invoice files
  pay|pay-invoice     Pay a Lightning invoice
EOT
}

# Channel usage
chan_usage() {
	cat << EOT
Usage: $(basename $0) chan [command]
$(print_separator)
  open        Open a Lightning channel (prompts for node ID and amount)
  close       Close a Lightning channel (cooperative or forced)
  list        List open Lightning channels with details
EOT
}

# Fees usage
fees_usage() {
	cat << EOT
Usage: $(basename $0) fees [command]
$(print_separator)
  check       Check current fee policies (optional: <channel_point>)
  set         Set fees interactively (global or specific channel)
  adjust      Adjust fees dynamically based on traffic or balance
  bump        Speed up a transaction (enter TX id and new sat/vB)
EOT
}

sli_version() { echo "SLi version: $sli_version"; }

# Try to make pretty outputs!
print_separator() {
	echo -e "${PURPLE}--------------------------------------------------------------------------------${NC}"
}
print_header() {
	echo -e "$1"; print_separator
}
error() {
	echo -e " ${RED}‚úò${NC} Error: $1\n"; exit 1
}

# Check if a command is available
check_command() {
	if ! command -v "$1" >/dev/null 2>&1; then
		error "${RED}$1${NC} is required but not installed."
	fi
}

# Log events for SLi. Rotate log if file exceeds 1MB
log_action() {
	echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$SLI_LOG"
	if [ $(stat -c %s "$SLI_LOG") -gt 1048576 ]; then
		mv -f "$SLI_LOG" "${SLI_LOG}.old"
		touch "$SLI_LOG"
	fi
}

#
# --- Core Functions ---
#

# Install packages recipes. Used by sli_init and sli_install
# We dont track them since they stay in user-space, if user wants to
# uninstall Sli he can run: sli purge
sli_install_recipes() {
	if [ -d "recipes" ]; then
		mkdir -p ${PKGS_RECIPES}
		for recipe in recipes/*; do
			echo " * Installing: $(basename $recipe)"
			sudo cp -f ${recipe} ${PKGS_RECIPES}
		done
	fi
}

# Should be run at first usage - Self install ;-)
sli_init() {
	pkg="sli"
	print_header "‚ö°Ô∏è SLi Initialization"
	echo -e "Creating data structure in: ${YELLOW}$SLI_DIR${NC}"
	mkdir -p ${INSTALLED_PKGS}/${pkg} ${CACHE_DIR}
	echo -e "Storing curent SLi version: ${CYAN}$sli_version${NC}"
	echo "version=\"$sli_version\"" > ${INSTALLED_PKGS}/${pkg}/pkg.conf
	
	echo -e " * Installing: /usr/local/bin/${pkg}"
	sudo cp -f ${0} /usr/local/bin 2>/dev/null
	echo "/usr/local/bin/sli" >  ${INSTALLED_PKGS}/${pkg}/files.list
	
	# Packages recipes
	sli_install_recipes
	
	# Install bash completion if init from sli src
	if [ -f "sli-bash-completion.sh" ]; then
		comp="/usr/share/bash-completion/completions/sli"
		echo " * Installing: SLi bash completion"
		sudo cp -f sli-bash-completion.sh ${comp}
		echo "$comp" >> ${INSTALLED_PKGS}/${pkg}/files.list
	fi
	
	[ -f "$PKGS_LIST" ] || pkgs_get_list
	# Create an empty sli.conf to let user customize some variables/paths
	if [ ! -f "$SLI_CONF" ]; then
		echo "# sli.conf: SLi configuration file" > ${SLI_CONF}
	fi
	print_separator
}

# View Sli Wallet and Node logs
sli_logs() {
	print_header "‚ö°Ô∏è SLi Packages, Wallet and Node Logs"
	cat ${SLI_LOG}
	print_separator
}

# Used for upgrade, we keep main branch for now since we have control
# on packages.list to modify versions.
sli_install() {

	PKG_NAME="sli"
	PKG_VERSION="$(pkg_get_version $PKG_NAME)"
	SRC_URL="https://github.com/0xeeli/sli/releases/download"
	TARBALL="${PKG_NAME}-${PKG_VERSION}.tar.gz"
	SRC_DIR="${PKG_NAME}-${PKG_VERSION}"
	DL_URL=${SRC_URL}/${PKG_VERSION}/${TARBALL}

	# Pre install
	pkg_pre_install "sli" "$PKG_VERSION"
	pkg_download_tarball
	pkg_extract_tarball

	# Install sli to /usr/local/bin
	echo -e "${CYAN}Install path: /usr/local/bin${NC}"
	echo " * Installing: sli"
	sudo cp -f ${SRC_DIR}/${PKG_NAME} /usr/local/bin
	echo "/usr/local/bin/sli" > ${PKG_DATA}/files.list
	
	# Packages recipes in PKGS_RECIPES
	sli_install_recipes
	
	# Install bash completion
	comp="/usr/share/bash-completion/completions/sli"
	echo " * Installing SLi bash completion..."
	sudo cp -f ${SRC_DIR}/sli-bash-completion.sh ${comp}
	echo "$comp" >> ${INSTALLED_PKGS}/${pkg}/files.list

	# Post install
	pkg_post_install
}

# Let user use lit in place of litd. also used to check file exist (ie litd.service)
service_check() {
	if [ -z "$2" ]; then
		error "Missing service name. Usage: sli $1 <service>"
	fi
	case "$2" in
		lit|loop|pool) service="${2}d" ;;
		*) service="$2" ;;
	esac
}

service_start() {
	service_check "$@" || return 1
	if [ "$(systemctl is-active ${service})" != "active" ]; then
		echo "‚ö°Ô∏è Starting $service service..."
		sudo systemctl start ${service}
	else
		echo "‚ö°Ô∏è $service service is active."
	fi
	wallet_db_exist
}

service_stop() {
	service_check "$@" || return 1
	if [ "$(systemctl is-active ${service})" == "active" ]; then
		echo "‚ö°Ô∏è Stopping $service service..."
		sudo systemctl stop ${service}
	else
		echo "‚ö°Ô∏è $service service is not active."
	fi
}

service_restart() {
	service_check "$@" || return 1
	echo "‚ö°Ô∏è Restarting $service service..."
	# sudo systemctl restart ${service} : Not always working with litd
	sudo systemctl stop ${service}
	sleep 2
	sudo systemctl start ${service}
	wallet_db_exist
}

# View service/daemon logs
service_logs() {
	local lines="${3:-30}"
	service_check ${@}
	print_header "‚ö°Ô∏è Showing last $lines lines of logs for: ${CYAN}${service}${NC}"
	journalctl -q -u "$service" -n "$lines" --no-pager
	print_separator
}

# View service/daemon status
service_status() {
	service_check ${@}
	print_header "‚ö°Ô∏è Service status for: ${CYAN}${service}${NC}"
	script -q -c "systemctl status ${service} --no-pager" /dev/null | sed '/^\s*‚îî‚îÄ/q'
	stty sane # Restore terminal settings
	print_separator
}

# Used by package install to generate a secure systemd unit. Generic version,
# some package may sed it or gen there own from a recipe.
# Usage example: config_service_unit "lnd" "LND Daemon" "notify" 
config_service_unit() {
	local unit="${1}.service" desc="$2" type="$3"
	if [ ! -f /etc/systemd/system/${unit} ]; then
		echo -e "${CYAN}Creating systemd service file:${NC} ${unit}"
		cat << EOF | sudo tee /etc/systemd/system/${unit} > /dev/null
[Unit]
Description=${desc}
After=network.target

[Service]
ExecStart=/usr/local/bin/${1}
User=$USER
Type=${type}
Restart=always
RestartSec=60
LimitNOFILE=8192
PrivateTmp=true
ProtectSystem=strict
NoNewPrivileges=true
MemoryDenyWriteExecute=true
AmbientCapabilities=CAP_NET_BIND_SERVICE

[Install]
WantedBy=multi-user.target
EOF
		# Track installed file
		echo "/etc/systemd/system/${unit}" >> ${PKG_DATA}/files.list
		sudo systemctl daemon-reload
		read -p "Do you wish to enable $1 on each boot ? (yes/no) " enable
		if [ "$enable" == "yes" ]; then
			echo "Enabling $1 on boot time..."
			sudo systemctl enable ${1} 2>/dev/null
		fi
	fi
}

# Show config file if any
config_show_file() {
	if [ ! -f "$1" ]; then
		error "No config file found. Try 'sli init <pkg>' to initialize."
	else
		cat "$1"
	fi
}

# Set config file path
config_show() {
	if [ ! -n "$1" ]; then
		echo -e "Usage: $(basename $0) show-config <pkg>\n" && exit 0
	fi
	print_header "‚ö°Ô∏è Configuration file for: ${CYAN}$1${NC}"
	case "$1" in
		albyhub|alby) config_show_file "$ALBY_CONF" ;;
		lit) config_show_file "$LIT_CONF" ;;
		lnd) config_show_file "$LND_CONF" ;;
		sli) config_show_file "$SLI_CONF" ;;
		*) error "No config file for: ${RED}$1${NC}" ;;
	esac
	print_separator
}

# Edit config if any. User can customize EDITOR with ~/.sli/sli.conf
config_edit_file() {
	if [ ! -f "$1" ]; then
		error "No config file found: Try 'sli init <pkg>' to initialize."
	else
		case "$1" in
			*.service) sudo ${EDITOR} ${1} ;;
			*) ${EDITOR} ${1} ;;
		esac
	fi
}

# Set config file path for editing
config_edit() {
	if [ ! -n "$1" ]; then
		echo -e "Usage: $(basename $0) edit <pkg>\n" && exit 0
	fi
	case "$1" in
		albyhub|alby) # We use systemd unit to configure Alb Hub
			config_edit_file "$ALBY_CONF"
			echo "Reloading systemd configuration..."
			sudo systemctl daemon-reload ;;
		lit) config_edit_file "$LIT_CONF" ;;
		lnd) config_edit_file "$LND_CONF" ;;
		sli) config_edit_file "$SLI_CONF" ;;
		*) error "No config file for ${RED}$1${NC}" ;;
	esac
}

# We check the files created by SLi
security_check() {
	print_header "‚ö°Ô∏è Security Check on SLi-Created Files"
	user=$(whoami)

	# List of files to check
	files=(
		"$WALLET_PASS"
		"$SLI_CONF"
		"$LIT_CONF"
		"$LND_CONF"
		#"$LND_DIR/data/chain/bitcoin/mainnet/admin.macaroon"
		"$BACKUP_DIR"/*.gpg
	)

	for file in "${files[@]}"; do
		# Handle glob expansion for backups
		if [[ "$file" == "$BACKUP_DIR"/*.gpg ]]; then
			if ! ls $file >/dev/null 2>&1; then
				continue  # Skip if no backups exist
			fi
		fi
		# Ensure file exists before checking
		if [ -f "$file" ]; then
			echo -e "Checking: ${YELLOW}$(basename "$file")${NC}"
			local perms=$(stat -c %a "$file")
			local owner=$(stat -c %U "$file")
			# Check permissions (should be 0600)
			if [ "$perms" != "600" ]; then
				echo -e " --> Permissions: ${RED}$perms${NC} (should be 0600)"
				read -p "Fix permissions to 0600? (yes/no): " fix
				if [ "$fix" == "yes" ]; then
					chmod 0600 "$file"
					echo "  ‚úî Fixed permissions to: 0600"
				fi
			else
				echo -e " --> Permissions: ${GREEN}0600${NC}"
			fi
			# Check ownership
			if [ "$owner" != "$user" ]; then
				echo -e " --> Owner: ${RED}$owner${NC} (should be $user)"
				read -p "Change owner to $user? (yes/no): " fix
				if [ "$fix" == "yes" ]; then
					chown "$user" "$file"
					echo "  ‚úî Fixed owner to $user"
				fi
			else
				echo -e " --> Owner: ${GREEN}$user${NC}"
			fi
			echo ""
		fi
	done
	print_separator
}

# Sing a message in interactive mode by the node‚Äôs identity private key
sign_message() {
	print_header "üí¨ Sing a message"; echo ""
	read -p "Message to sing: " message
	echo -e "\n${CYAN}Signature:${NC}\n"
	if [ -n "$message" ]; then
		lncli signmessage "$message" | jq -r '.signature'
	fi
	print_separator
}

# Connect to a remote peer
peer_connect() {
	print_header "‚ö°Ô∏è Connect to a peer. Enter: <pubkey>@IP:port"
	echo ""
	read -p "Peer: " peer
	[ -n "$peer" ] && lncli connect ${peer}
}

# Disconnect a remote peer
peer_disconnect() {
	print_header "‚ö°Ô∏è Disconnect a peer. Enter: <pubkey>"
	echo ""
	read -p "Peer: " peer
	[ -n "$peer" ] && lncli disconnect ${peer}
}

# List connected peers with IP and Alias
peers_list() {
    peers_json=$(lncli listpeers)
    print_header "‚ö°Ô∏è Connected peers: ${CYAN}$(echo "$peers_json" | jq -r '.peers | length')${NC}"
    echo ""
    for peer in $(echo "$peers_json" | jq -r '.peers[].pub_key'); do
        # Get peer info (pub_key and address) from listpeers
        peer_info=$(echo "$peers_json" | jq -r --arg pk "$peer" '.peers[] | select(.pub_key == $pk) | "Pub Key: \(.pub_key)\nAddress: \(.address)"')
        
        # Get node alias from getnodeinfo
        alias_output=$(lncli getnodeinfo "$peer" 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$alias_output" ]; then
            alias_info=$(echo "$alias_output" | jq -r '.node | "Alias  : \(if .alias == null or .alias == "" then "Unspecified" else .alias end)"')
        else
            alias_info="Alias  : Unknown (Node not found)"
        fi
        
        # Combine and output with an empty line
        echo -e "$peer_info\n$alias_info\n"
    done
    print_separator
}

#
# --- Wallet Tools and Functions ---
#

# Create a wallet if none
wallet_init() {
	if [ "$1" == "--header" ]; then
		print_header "‚ö°Ô∏è Wallet Initialization"
	fi
	if [ ! -f "$WALLET_DB" ]; then
		
		# Create or use existing wallet password
		if [ ! -f "$WALLET_PASS" ]; then
			read -p "Create a secure password ? (yes/no) " gen_walletpass
			if [ "$gen_walletpass" == "yes" ]; then
				password_init wallet-password
			fi
		else
			echo "Found existing Wallet password:"
			echo -e " --> ${YELLOW}$WALLET_PASS${NC}"
			echo " --> $(cat $WALLET_PASS)"
			echo ""
		fi
		
		echo -e "Launching: ${GREEN}lncli create${NC}"
		echo "üîí Paste your generated or own Wallet password"
		echo ""
		lncli create
	else
		echo "A wallet database already exist:"
		echo -e " --> ${YELLOW}${WALLET_DB}${NC}"
	fi
}

wallet_info() {
	if [ "$(lncli state | grep LOCKED)" ]; then
		echo "üîí Wallet is locked."
	else
		echo "üîì Wallet is unlocked."
	fi
}

# Used by: service_start and service_restart (litd or lnd)
wallet_db_exist() {
	case "$service" in
		litd|lnd)
			if [ ! -f "$WALLET_DB" ]; then
				echo "üîí No wallet.db file found."
				return 1
			fi ;;
		cln)
			# If Core lighning is implemented ;-)
			echo "Core lighning" ;;
	esac
}

# Create a new onchain wallet
wallet_new_address() {
	check_command "jq"
	print_header "‚ö°Ô∏è New ‚ÇøTC Address for onchain funds (p2wkh)"
	addr=$(lncli newaddress p2wkh | jq -r '.address')
	if [ -n "$addr" ]; then
		echo "New ‚ÇøTC address: $addr"
		log_action "Created BTC onchain address: $addr"
	else
		echo -e "${RED}Is your litd or lnd daemon running and wallet unlocked ?${NC}"
	fi
	print_separator
}

# Parse JSON output with jq to nicely display wallet(s) and show balance(s)
wallet_list_addresses() {
	check_command "jq"
	print_header "‚ö°Ô∏è Onchain ‚ÇøTC Addresses"
	# Exclude addresses without funds ?
	#lncli wallet addresses list | jq -r '.account_with_addresses[].addresses[] | select(.balance != "0") | "\(.address) \(.balance)"'
	lncli wallet addresses list | jq -r '.account_with_addresses[].addresses[] | "\(.address) \(.balance)"'
	print_separator
}

wallet_balance() {
	check_command "jq"
	print_header "‚ö°Ô∏è Wallet Balances"
	echo "On-chain Balance:"
	lncli walletbalance | jq -r '"\(.confirmed_balance) sat (confirmed) / \(.unconfirmed_balance) sat (unconfirmed)"'
	echo -e "\nChannel Balance:"
	lncli channelbalance | jq -r '"\(.balance) sat (local) / \(.remote_balance.sat) sat (remote)"'
	print_separator
}

# Let send some sats
wallet_send_onchain() {
	print_header "üí∞ Send ‚ÇøTC Onchain (Amount in sat)"; echo ""
	read -p "Address: " addr
	read -p "Amount : " amt
	if [[ ! "$amt" =~ ^[0-9]+$ ]]; then
		error "Invalid amount: $amt Must be numeric."
	fi
	if [ -n "$addr" ] && [ -n "$amt" ]; then
		lncli sendcoins --addr="$addr" --amount="$amt"
		log_action "Sent $amt sats to $addr"
	else
		error "Address or amount missing."
	fi
}

wallet_invoice_check() {
	if [ -z "$invoice" ]; then
		error "Failed to generate invoice. Is your node running and wallet unlocked ?"
	fi
}

# Generate interactively a Lightning invoice
wallet_invoice() {
	check_command "jq"
	print_header "‚ö°Ô∏è Generate Lightning Invoice\n"
	
	# Get amount and memo
	read -p "Amount (sat, default: 1000): " amt
	amt=${amt:-1000}
	read -p "Memo (optional): " memo
	if [[ ! "$amt" =~ ^[0-9]+$ ]]; then
		error "Invalid amount: $amt. Must be numeric."
	fi
	wallet_invoice_check

	# Display invoice
	if [ -n "$memo" ]; then
		invoice=$(lncli addinvoice --amt="$amt" --memo="$memo" | jq -r '.payment_request')
		log_action "Generated invoice for: $amt sat with memo $memo"
	else
		invoice=$(lncli addinvoice --amt="$amt" | jq -r '.payment_request')
		log_action "Generated invoice for: $amt"
	fi
	echo -e "${CYAN}Invoice:${NC} $invoice\n"
	print_separator
}

# Generate an invoice and save QR code + text so we can display the invoice
# from a CGI|PHP page or static html page (manually or generated by a script if no CGI)
wallet_qr_invoice() {
	check_command "jq"
	check_command "qrencode"
	local invoice_qr="${INVOICE_DIR}/invoice.png"
	local invoice_file="${INVOICE_DIR}/invoice.txt"

	print_header "‚ö°Ô∏è Generate Lightning Invoice with QR Code"; echo ""
	read -p "Amount (sat, default: 1000): " amt
	amt=${amt:-1000}
	read -p "Memo (optional): " memo
	if [[ ! "$amt" =~ ^[0-9]+$ ]]; then
		error "Invalid amount: $amt. Must be numeric."
	fi

	# Generate invoice
	if [ -n "$memo" ]; then
		invoice=$(lncli addinvoice --amt="$amt" --memo="$memo" | jq -r '.payment_request')
		log_action "Generated QR invoice for: $amt sat with memo $memo"
	else
		invoice=$(lncli addinvoice --amt="$amt" | jq -r '.payment_request')
		log_action "Generated QR invoice for: $amt sat"
	fi
	wallet_invoice_check

	# Ensure output dir exists
	mkdir -p "$INVOICE_DIR"

	# Generate QR code PNG
	qrencode -o "$invoice_qr" -s 6 "$invoice"
	if [ $? -ne 0 ]; then
		error "Failed to generate QR code."
	fi

	# Save invoice text
	echo "Invoice: $invoice" > "$invoice_file"
	echo "Amount : $amt sat" >> "$invoice_file"
	[ -n "$memo" ] && echo "Memo   : $memo" >> "$invoice_file"

	echo -e "${CYAN}Invoice:${NC} $invoice"
	echo -e "${YELLOW}QR Code saved to:${NC} $invoice_qr"
	echo ""
	print_separator
}

# Manually delete invoice.png and invoice.txt, ca be done via CGI too
wallet_remove_qr_invoice() {
	print_header "üí∏ Remove QR Invoice"
	echo "Removing latest invoice files..."
	rm -f ${INVOICE_DIR}/*
}

# Pay a Lightning invoice directly
wallet_pay_invoice() {
	check_command "jq"
	print_header "üí∏ Pay a Lightning Invoice"; echo ""
	read -p "Invoice (bolt11): " invoice
	if [ -n "$invoice" ]; then
		lncli payinvoice "$invoice"
	else
		error "No invoice provided"
	fi
	echo ""
	print_separator
}

#
# --- Channel functions ---
#

# Open a channel
chan_open() {
	print_header "üîó Open a Channel (Amount in sat)"; echo ""
	read -p "Node ID: " node
	read -p "Amount : " amt
	read -p "Fee rate (sats/vB): " fee
	# ensure fast transactions here or/and in lit.conf
	# lnd.bitcoin.feerate=5
	if [ -n "$node" ] && [ -n "$amt" ] && [ -n "$fee" ]; then
		lncli openchannel --node_key="$node" --local_amt="$amt" --sat_per_vbyte="$fee" || exit 1
		log_action "Opened channel with $node for: $amt sats"
	fi
}

# Close a channel cooperatively or forced
chan_close() {
	check_command "jq"
	print_header "üîó Close a Lightning Channel"
	echo "Open channels:"
	lncli listchannels | jq -r '.channels[] | "Peer: \(.remote_pubkey) | Chan ID: \(.channel_point)"'
	echo ""
	read -p "Channel Point (e.g., txid:output): " chan_point
	read -p "Force close? (yes/no, default: no): " force
	force=${force:-no}
	if [ "$force" == "yes" ]; then
		lncli closechannel --force "$chan_point"
		log_action "Force-closed channel: $chan_point"
	else
		lncli closechannel "$chan_point"
		log_action "Cooperatively closed channel: $chan_point"
	fi
	print_separator
}

# List open channels
chan_list() {
	check_command "jq"
	print_header "üîó Open Lightning Channels"
	lncli listchannels | jq -r '.channels[] | "Peer: \(.remote_pubkey)\nCapacity: \(.capacity) sat | Local: \(.local_balance) sat | Active: \(.active)"'
	print_separator
}

#
# --- Fees functions ---
#

# Check the current fees policy
fees_check() {
	check_command "jq"
	print_header "‚ö°Ô∏è Current Fee Policies"
	lncli listchannels | jq -r '.channels[].chan_id' | xargs -I{} lncli getchaninfo {} | \
		jq -r '"Channel ID: \(.channel_id) | Base Fee: \(.node1_policy.fee_base_msat // "N/A") msat | Fee Rate: \(.node1_policy.fee_rate_milli_msat // "N/A") ppm"'
	print_separator
}

# Set routing fees
fees_set() {
	check_command "jq"
	check_command "bc"
	print_header "‚ö°Ô∏è Set Routing Fees"
	echo "Options:"
	echo " --> Leave blank for global settings (all channels)"
	echo " --> Enter a channel point (e.g., txid:output) for a specific channel"
	echo ""
	read -p "Channel Point (optional): " chan_point
	echo ""
	echo "Suggested starting fees for new nodes:"
	echo " --> Base Fee: 100 msat (0.1 sat)"
	echo " --> Fee Rate: 200 ppm (0.02%)"
	
	echo ""
	read -p "Base Fee (msat, default: 100): " base_fee
	base_fee=${base_fee:-100}
	read -p "Fee Rate (ppm, default: 200): " fee_rate
	fee_rate=${fee_rate:-200}
	if ! [[ "$base_fee" =~ ^[0-9]+$ ]] || ! [[ "$fee_rate" =~ ^[0-9]+$ ]]; then
		error "Invalid input: Base Fee and Fee Rate must be numeric."
	fi
	
	fee_rate_decimal=$(echo "scale=6; $fee_rate / 1000000" | bc)
	if [ -z "$chan_point" ]; then
		echo "Applying globally: Base Fee: $base_fee msat | Fee Rate: $fee_rate ppm"
		
		lncli updatechanpolicy --base_fee_msat "$base_fee" --fee_rate "$fee_rate_decimal" \
			--min_htlc_msat 1000 --time_lock_delta 40 | \
			jq -r 'if .failed_updates == [] then "‚úî Fees updated successfully." else "Error occurred" end'
		
		log_action "Set global fees: Base $base_fee msat, Rate $fee_rate ppm"
	else
		echo "Applying to channel $chan_point"
		echo " --> Base Fee: $base_fee msat | Fee Rate: $fee_rate ppm"
		
		lncli updatechanpolicy --base_fee_msat "$base_fee" --fee_rate "$fee_rate_decimal" \
			--chan_point "$chan_point" --min_htlc_msat 1000 --time_lock_delta 40 | \
			jq -r 'if .failed_updates == [] then "‚úî Fees updated successfully." else "Error occurred" end'
		
		log_action "Set fees for channel $chan_point: Base $base_fee msat, Rate $fee_rate ppm"
	fi
	print_separator
}

# Dynamically adjust fees
fees_adjust() {
	check_command "jq"
	print_header "‚ö°Ô∏è Dynamically Adjust Fees"
	echo "Select a channel to adjust:"
	lncli listchannels | jq -r '.channels[]| "Channel: \(.channel_point)"'
	#lncli listchannels | jq -r '.channels[]| "Channel: \(.channel_point) | Local: \(.local_balance) sat | Remote: \(.remote_balance.sat)"'
	echo ""
	read -p "Channel Point: " chan_point
	if [ -z "$chan_point" ]; then
		error "Please specify a channel point."
	fi
	
	current_base=$(lncli getchaninfo "$(lncli listchannels | jq -r ".channels[] | select(.channel_point == \"$chan_point\") | .chan_id")" | jq -r '.policy1.fee_base_msat')
	current_rate=$(lncli getchaninfo "$(lncli listchannels | jq -r ".channels[] | select(.channel_point == \"$chan_point\") | .chan_id")" | jq -r '.policy1.fee_rate_ppm')
	
	echo "Current: Base Fee: $current_base msat | Fee Rate: $current_rate ppm"
	echo ""
	echo -e "${CYAN}Adjustment options:${NC}"
	echo " --> Lower fees to boost traffic (e.g., halve current fees)"
	echo " --> Raise fees to increase earnings or slow outbound liquidity drain"
	echo ""
	read -p "Action (lower/raise): " action
	
	case "$action" in
		lower)
			new_base=$((current_base / 2))
			new_rate=$((current_rate / 2)) ;;
		raise)
			new_base=$((current_base + 50))
			new_rate=$((current_rate + 100)) ;;
		*)
			error "Invalid action. Use 'lower' or 'raise'." ;;
	esac
	new_rate_decimal=$(echo "scale=6; $new_rate / 1000000" | bc)
	echo "Applying: Base Fee: $new_base msat | Fee Rate: $new_rate ppm"
	
	lncli updatechanpolicy --base_fee_msat "$new_base" --fee_rate "$new_rate_decimal" \
		--chan_point "$chan_point" --min_htlc_msat 1000 --time_lock_delta 40
	log_action "Adjusted fees for $chan_point: Base $new_base msat, Rate $new_rate ppm ($action)"
	echo "‚úî Fees adjusted successfully."
	print_separator
}

# Speed up a transaction
fees_bump() {
	print_header "‚ö°Ô∏è Bump (speed up) a transaction"
	echo "Make sure your transaction is flaged RBF (Replace-by-fee)"
	echo ""
	read -p "TX id: " tx
	read -p "New sat/vB: " spb
	[ -n "$tx" ] || exit 0
	[ -n "spb" ] || exit 0
	lncli wallet bumpfee --sat_per_byte ${spb} ${tx}:0
}

#
# --- Tools functions ---
#

# Convert macaroon to HEX
macaroon_to_hex() {
	check_command "xxd"
	local macaroon="${1:-admin}"
	local macaroon="${macaroon%.*}"
	local path="${LND_DIR}/data/chain/bitcoin/mainnet/${macaroon}.macaroon"
	print_header "‚ö°Ô∏è Convert ${CYAN}$macaroon${NC} macaroon to HEX"
	if [ ! -f "${path}" ]; then
		echo "No macaroon found at:"
		echo " --> ${path}"
	else
		xxd -ps -u -c 1000 "${path}"
	fi
	print_separator
}

# Generate strong passwords for Lit UI or Wallet. Prefer pwgen who
# include special characters
passwords_gen() {
	if [ -x /usr/bin/pwgen ] && [ "$1" != "openssl" ]; then
		wallet_pwd=$(pwgen -c -n -y -s 30 1)
		ui_pwd=$(pwgen -c -n -y -s 30 1)
	else
		wallet_pwd=$(openssl rand -hex 24 | tr -d "=+/")
		ui_pwd=$(openssl rand -hex 24 | tr -d "=+/")
	fi
}

# Change passwords for Lit UI and/or Wallet
passwords_change() {
	print_header "‚ö°Ô∏è Change Passwords using: pwgen or openssl"; echo ""
	
	passwords_gen ${2}
	echo "Wallet --> ${wallet_pwd}"
	echo "Lit UI --> ${ui_pwd}"
	echo ""
	echo -e "${CYAN}Write down your new password in a secure place!${NC}"
	echo ""
	
	read -p "Do you wish to change Wallet password ? (yes/no) " change
	if [ "$change" == "yes" ]; then
		echo "You can copy/paste it below."
		lncli changepassword
		# Update a wallet_password file ?
		if [ -f "$WALLET_PASS" ]; then
			echo "Updating: $WALLET_PASS"
			echo "${wallet_pwd}" > "${WALLET_PASS}"
			echo "Setting secure permissions: read only by $USER (0600)"
			chmod 0600 "${WALLET_PASS}"
		fi
	fi
	unset change && echo ""

	# lit.conf uipassword=
	if [ -f "$LIT_CONF" ]; then
		read -p "Do you wish to change Lit Web UI password ? (yes/no) " change
		if [ "$change" == "yes" ]; then
			echo "Updating: $LIT_CONF"
			sed -i s/"uipassword=.*"/"uipassword=${ui_pwd}"/ ${LIT_CONF}
			# Lit must reload to use the new password
			service_restart "restart" "litd"
			echo ""
			echo "Make sure your wallet is unlock to login with your new password."
		fi
	fi
	unset wallet_pwd ui_pwd
	echo "" && print_separator
}

# Handle passwords when initializing
password_init() {
	case "$1" in
		ui-password)
			passwords_gen "openssl"
			echo ""
			echo -e "${YELLOW}Lit UI pass -->${NC} ${ui_pwd}"
			echo ""
			echo "Write down or copy/past your UI password in a secure place."
			read -p "When your password is saved: press ENTER to continue"
			echo ""
			echo -e "${CYAN}Storing Lit UI password in:${NC} $LIT_CONF"
			sed -i s/"uipassword=.*"/"uipassword=${ui_pwd}"/ ${LIT_CONF}
			unset ui_pwd ;;
		wallet-password)
			passwords_gen "openssl"
			echo ""
			echo -e "${YELLOW}Wallet pass -->${NC} ${wallet_pwd}"
			echo ""
			echo "Write down or copy/past your Wallet password in a secure place."
			read -p "When your password is saved: press ENTER to continue"
			echo ""
			echo -e "${CYAN}Storing Wallet password in:${NC} $WALLET_PASS"
			echo "${wallet_pwd}" > "${WALLET_PASS}"
			echo "Setting secure permissions: read only by $USER (0600)"
			chmod 0600 "${WALLET_PASS}"
			echo "" ;;
	esac
}

# Check if a backup file was given
node_backup_check_path() {
	BACKUP_FILE="$1"
	if [ -z "$BACKUP_FILE" ]; then
		error "Missing backup file path: $(basename $0) $1 <file.gpg>"
	fi
}

# Function to create a backup
node_backup() {
	check_command "gpg"
	print_header "‚ö°Ô∏è Creating Node Backup"
	# Ensure backup directory exists
	echo " * Preparing backup directories..."
	mkdir -p "$BACKUP_DIR" "$TMP_BACKUP_DIR"

	echo " * Exporting Static Channel Backup (SCB)..."
	lncli exportchanbackup --all --output_file="$TMP_BACKUP_DIR/channel.backup"

	echo " * Copying LND files to backup directory..."
	cp -r "$LND_DIR" "$TMP_BACKUP_DIR/"

	echo " * Creating tarball archive..."
	TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
	BACKUP_FILE="$BACKUP_DIR/lnd_backup_$TIMESTAMP.tar.gz"
	tar -czf "$BACKUP_FILE" -C "$TMP_BACKUP_DIR" .

	echo " * Cleaning up temporary files..."
	rm -rf "$TMP_BACKUP_DIR"

	echo " * Encrypting backup..."
	gpg --batch --yes --passphrase-file "$WALLET_PASS" -c "$BACKUP_FILE"
	rm -f "$BACKUP_FILE"
	echo " * Setting backup file permissions to: 0600 "
	chmod 0600 "$BACKUP_FILE"

	size=$(du -sh ${BACKUP_FILE}.gpg | cut -d "	" -f 1)
	echo -e " ‚úî Backup completed successfully: ${CYAN}${size}${NC}"
	echo -e "Encrypted backup: ${YELLOW}$(basename ${BACKUP_FILE}.gpg)${NC}"
	print_separator
}

# Function to restore a backup
node_backup_restore() {
	node_backup_check_path "$2"
	print_header "‚ö°Ô∏è Restoring Node Backup"
	# Ensure backup directory exists
	echo " * Preparing to restore backup..."
	mkdir -p "$BACKUP_DIR" "$TMP_BACKUP_DIR"

	echo -e " * Decrypting: ${YELLOW}$(basename $BACKUP_FILE)${NC}"
	gpg --batch --yes --passphrase-file "$WALLET_PASS" \
		-o "$TMP_BACKUP_DIR/lnd_backup.tar.gz" -d "$BACKUP_FILE"

	echo " * Extracting backup..."
	tar -xzf "$TMP_BACKUP_DIR/lnd_backup.tar.gz" -C "$TMP_BACKUP_DIR"

	echo " * Restoring LND files..."
	cp -r "$TMP_BACKUP_DIR/.lnd" "$HOME/"

	echo " * Cleaning up temporary files..."
	rm -rf "$TMP_BACKUP_DIR"

	echo " ‚úî Restore completed. "
	echo -e "${CYAN}Restart LND/LiTd and unlock your wallet (if no auto-unlock).${NC}"
	print_separator
}

# Function to extract a backup for inspection
node_backup_extract() {
	node_backup_check_path "$2"
	print_header "‚ö°Ô∏è Extracting Node Backup"
	# Ensure extract directory exists
	echo " * Preparing for extraction..."
	mkdir -p "$BACKUP_DIR" "$EXTRACTED_DIR"

	echo -e " * Decrypting: ${YELLOW}$(basename $BACKUP_FILE)${NC}"
	gpg --batch --yes --passphrase-file "$WALLET_PASS" \
		-o "$EXTRACTED_DIR/lnd_backup.tar.gz" -d "$BACKUP_FILE" || return 1

	echo " * Extracting backup contents for inspection..."
	tar -xzf "$EXTRACTED_DIR/lnd_backup.tar.gz" -C "$EXTRACTED_DIR"
	rm -f "$EXTRACTED_DIR/lnd_backup.tar.gz"

	echo " ‚úî Backup extracted in: $EXTRACTED_DIR/lnd_backup"
	echo -e "${CYAN}You can now inspect your files.${NC}"
	print_separator
}

# To be improved if/when LND is integrated
node_health() {
	check_command "jq"
	print_header "‚ö°Ô∏è Node Health Check"
	
	# Node daemon
	echo "Service Status:"
	if systemctl is-active litd >/dev/null 2>&1; then
		daemon="litd" # Used by memory usage below
		echo -e " --> ${YELLOW}litd${NC}: ${GREEN}running${NC}"
	elif systemctl is-active lnd >/dev/null 2>&1; then
		daemon="lnd" # Used by memory usage below
		echo -e " --> ${YELLOW}lnd${NC}: ${GREEN}running${NC}"
	else
		status="stopped" # Avoid calling lncli below
		echo -e " --> node: ${RED}stopped${NC}"
	fi
	echo ""
	
	if [ "$status" != "stopped" ]; then
		# Sync status
		echo "Sync Status:"
		lncli getinfo | jq -r '" --> Synced: \(.synced_to_chain) | Block Height: \(.block_height)"'
		
		# Connected peers
		echo -en "\nConnected Peers: "
		lncli listpeers | jq -r '.peers | length' # | xargs echo " --> Peers:"
	
		# Open channel(s)
		echo -n "Channels Count : "
		lncli listchannels | jq -r '.channels[] | "\(.chan_id)"' | wc -l
		echo ""
	fi
	
	# Node size and memory usage
	disk_usage=$(du -sh ${LND_DIR} | cut -d $'\t' -f 1 | sed 's/M/ MB/' | sed 's/G/ GB/')
	echo -e "Disk usage  : ${disk_usage}"
	
	# Node memory usage
	if [ "$status" != "stopped" ]; then
		ps -p $(pgrep $daemon) -o %mem,rss | tail -n 1 | \
			awk '{mb=$2/1024; if(mb>=1024) print \
				"Memory usage: "mb/1024" GB "$1"%"; else print \
				"Memory usage: "int(mb)" MB | "$1"%"}'
	else
		echo -e "RAM Usage  : N/A"
	fi
	
	print_separator
}

# A tool to ping Amboss Health Check to get nice graph. Should be run
# as a systemd timer unit. 
# See: https://old-docs.amboss.tech/docs/api-docs/monitoring/healthChecks
ping_amboss() {
	check_command "lncli"
	date=$(date -u +%Y-%m-%dT%H:%M:%S%z)
	signed=$(lncli signmessage "$date" | jq -r .signature)
	json="{\"query\": \"mutation HealthCheck(\$signature: String!, \$timestamp: String!) { healthCheck(signature: \$signature, timestamp: \$timestamp) }\", \"variables\": {\"signature\": \"$signed\", \"timestamp\": \"$date\"}}"

	echo "Pinging Amboss Health Check API..."
	echo "${json}" | curl -s --data-binary @- -H "Content-Type: application/json" \
		-X POST --output /dev/null ${AMBOSS_API}
	log_action "Ping to Amboss Health Check API"
	
	# Cron is obsolete with Systemd timers. Let's creat a systemd timer
	# to run a ping to Amboss each hour. Let user active it or not.
	if [ ! -f "/etc/systemd/system/ping-amboss.service" ]; then
		files_list="${INSTALLED_PKGS}/sli/files.list"
		echo "Creating systemd service & timer files..."
		cat << EOT >> ${CACHE_DIR}/ping-amboss.service
[Unit]
Description="Ping Amboss API"

[Service]
ExecStart=/usr/local/bin/sli ping-amboss
User=$USER
EOT
	# Timer
	cat << EOT >> ${CACHE_DIR}/ping-amboss.timer
[Unit]
Description="Ping Amboss API every hour"

[Timer]
OnBootSec=5min
OnCalendar=*-*-* *:00:00
Unit=ping-amboss.service

[Install]
WantedBy=multi-user.target
EOT
		sudo mv -f ${CACHE_DIR}/ping-amboss.* /etc/systemd/system
		read -p "Do you wish to run a ping to Amboss each hour ? (yes/no) " answ
		if [ "$answ" == "yes" ]; then
			echo -e "${YELLOW}Enabling systemd timer to ping Amboss every hour...${NC}"
			sudo systemctl start ping-amboss.timer
			sudo systemctl enable ping-amboss.timer 2>/dev/null
		else
			echo -e "\nTo start Amboss ping timer:"
			echo " --> sudo systemctl start ping-amboss.timer"
			echo "To enable Amboss ping timer on each boot:"
			echo " --> sudo systemctl enable ping-amboss.timer"
		fi
		# Track files so we remove them on 'sli remove sli'
		echo -e "\nTracking installed files in: $files_list"
		echo "$service" >> ${files_list}
		echo "$timer" >> ${files_list}
	fi
}

#
# --- Packages Manager functions ---
#

# Packages recipes can be downloaded individualy since they can be updated
# or added without a new SLi release.
pkg_get_recipe() {
	local action="$1" pkg="$2"
	
	# Check if package exist in DB or a recipe in current dir
	if ! grep -q "^${pkg}|" ${PKGS_LIST} && [ ! -f ${pkg}_recipe.sh ]; then
		error "Package ${RED}$pkg${NC} don't exist"
	else
		# Ensure local recipes dir exist
		mkdir -p ${PKGS_RECIPES}
	fi
	
	# sli get-recipe <pkg>
	if [ "$action" == "get" ] && [ ! -f ${pkg}_recipe.sh ]; then
		echo -e "Downloading ${CYAN}$pkg${NC} recipe..."
		wget -q --show-progress ${PKGS_RECIPES_URL}/${pkg}_recipe.sh
	
	# No download if recipe exist in current dir
	elif [ "$action" == "get" ] && [ -f ${pkg}_recipe.sh ]; then
		echo -e "Recipe exist: ${YELLOW}$(pwd)/${pkg}_recipe.sh${NC}"
	
	# Get and install recipe if needed
	elif [ "$action" == "install" ] && [ ! -f ${PKGS_RECIPES}/${pkg}_recipe.sh ] && [ ! -f ${pkg}_recipe.sh ]; then
		echo "Downloading $pkg recipe..."
		cd ${PKGS_RECIPES}
		wget -q --show-progress ${PKGS_RECIPES_URL}/${pkg}_recipe.sh
	fi
}

# We can install or init a package from a sourced recipe.sh script (providing
# pkgname_install, pkgname_init, etc) from the curremt dir, useful for development.
# Then check for a recipe in PKGS_RECIPES. Example: pkg_source_recipe "pkg"
pkg_source_recipe() {
	if [ -f ${1}_recipe.sh ]; then
		echo -e "Recipe: ${YELLOW}$(pwd)/${1}_recipe.sh${NC}\n"
		source ${1}_recipe.sh
	else
		echo -e "Recipe: ${YELLOW}${PKGS_RECIPES}/${1}_recipe.sh${NC}\n"
		source ${PKGS_RECIPES}/${1}_recipe.sh
	fi
}

# First check sli itself, then load a custom recipe, and finaly use 
# built-in function.
pkg_install() {
	local pkg="$1"
	if [ "$pkg" == "sli" ]; then
		echo "If you need to reinstall this version, run: sli init"
		echo "" && exit 0
	fi
	# Use built-in package (sli)
	if [ $(declare -F ${pkg}_install) ]; then
		${pkg}_install
	else
		pkg_get_recipe "install" "$pkg"
		pkg_source_recipe "$pkg"
		if [ ! $(declare -F ${pkg}_install) ]; then
			error "Missing: ${pkg}_install in recipe\n"
		fi
		${pkg}_install
	fi
}

pkg_get_version() {
	grep "^${1}|" ${PKGS_LIST} | cut -d "|" -f 2
}

# Download pkg if needed (we are in CACHE_DIR)
pkg_download_tarball() {
	if [ ! -f ${TARBALL} ]; then
		echo "Downloading tarball file..."
		wget -q --show-progress ${DL_URL} -O ${TARBALL} || \
			{ rm -f ${TARBALL}; error "Can't download ${TARBALL}"; }
	else
		echo "Using cache: ${TARBALL}"
	fi
}

# Ensure we extract in SRC_DIR
pkg_extract_tarball() {
	echo "Extracting: $TARBALL"
	mkdir -p ${SRC_DIR}
	case "$TARBALL" in
		*.tar.gz) tar xzf ${TARBALL} ;;
		"alby"*.tar.bz2) tar xjf ${TARBALL} -C ${SRC_DIR} ;; # -C for Alby
		*.tar.bz2) tar xjf ${TARBALL} ;;
		*.zip) unzip ${TARBALL} ;;
	esac
}

pkgs_get_list() {
	mkdir -p ${CACHE_DIR} && cd ${CACHE_DIR}
	echo "Fetching packages list from GitHub..."
	wget -q ${PKGS_URL} || error "Can't fetch packages list"
	mv -f packages.list ${SLI_DIR}
}

# Before install: called in pkg install function, ie lit_install
pkg_pre_install() {
	PKG_NAME="$1"
	PKG_VERSION="$2"
	PKG_DATA=${INSTALLED_PKGS}/${PKG_NAME}
	
	# Already installed ?
	if [ -f "${PKG_DATA}/pkg.conf" ]; then
		# Set version=
		source ${PKG_DATA}/pkg.conf
		# Upgrade or custom version ?
		if [ "$version" == "$PKG_VERSION" ]; then
			echo -e "${CYAN}$PKG_NAME is already installed${NC}"
			echo -e "Version: $version\n"; exit 0
		else
			# Remove version in pkg.conf in case of upgrade, will be add later 
			# by pkg_post_install
			sed -i '/version=*/'d ${PKG_DATA}/pkg.conf
		fi
	fi
	
	# We must handle packages conflict here. If lit is installed 
	# warn user: loop, pool will not work with litd, they need LND.
	case ${PKG_NAME} in
		loop|pool)
			if [ -d "${INSTALLED_PKGS}/lit" ]; then
				echo -e "The Lit package is installed and conflicts with: ${CYAN}${PKG_NAME}${NC}"
				echo "Lit is a bundle that provides loop, pool, lncli, and its own daemon, litd."
				echo "If you install $PKG_NAME, it will not work properly with litd."
				echo "You can either remove Lit or continue, and SLi will erase the $PKG_NAME Lit version."
				echo ""
				read -p "Continue installation anyway ? (yes/no) " answer
				echo ""
				[ "$answer" != "yes" ] && exit 0 
			fi ;;
		lnd)
			if [ -d "${INSTALLED_PKGS}/lit" ]; then
				echo -e "The Lit package is installed and conflicts with: ${CYAN}${PKG_NAME}${NC}"
				echo "Lit is a bundle that provides litd and lncli (LND command line interface)"
				echo "If you plan to use LND as your node daemon, you can always use LiT"
				echo "You can use LiT remote mode, so you have LiT for UI and LND as deamon"
				echo ""
				read -p "Continue installation anyway ? (yes/no) " answer
				echo ""
				[ "$answer" != "yes" ] && exit 0
			fi ;;
	esac
	
	print_header "‚ö°Ô∏è Installing: $PKG_NAME $PKG_VERSION"
	# Continuing for install/upgrade - We work in SLi cache directory
	mkdir -p ${PKG_DATA} ${CACHE_DIR} && cd ${CACHE_DIR}
	# Keep track of previous installed files
	mv -f ${PKG_DATA}/files.list ${PKG_DATA}/files.list.old 2>/dev/null
}

# After install
pkg_post_install() {
	# Record version & clean cache
	echo "version=\"$PKG_VERSION\"" >> ${PKG_DATA}/pkg.conf
	[ "$1" == "keep_src" ] || rm -rf ${SRC_DIR}
	log_action "Installed package: $PKG_NAME $PKG_VERSION"
	unset PKG_NAME SRC_URL PKG_VERSION TARBALL SRC_DIR DL_URL
	print_separator
}

pkgs_list() {
	count=$(ls $INSTALLED_PKGS | wc -l)
	print_header "‚ö°Ô∏è Installed packages: ${CYAN}${count}${NC}"
	# Installed packages
	[ -d "$INSTALLED_PKGS" ] || mkdir -p ${INSTALLED_PKGS}
	for pkg in $(ls ${INSTALLED_PKGS}); do
		source ${INSTALLED_PKGS}/${pkg}/pkg.conf
		echo "$pkg $version" | awk '{ printf "%-15s %-30s\n", $1, $2}'
		unset version
	done
	print_separator
	
	count=$(cat $PKGS_LIST | wc -l)
	print_header "\n‚ö°Ô∏è Available packages: ${CYAN}${count}${NC}"
	# Ensure packages.list was downloaded
	[ -f "$PKGS_LIST" ] || pkgs_get_list
	for pkg in $(cat ${PKGS_LIST}); do
		name=$(echo $pkg | cut -d "|" -f 1)
		version=$(echo $pkg | cut -d "|" -f 2)
		echo "$name $version" | awk '{ printf "%-15s %-30s\n", $1, $2}'
	done
	print_separator
}

# Downlad a packages.list, compare installed version to the list
# upgrade everything
pkgs_upgrade() {
	print_header "‚ö°Ô∏è Packages Upgrade"
	pkgs_get_list
	echo -e "Checking for packages update...\n"
	log_action "Checking for packages update"
	
	# Simply check if version differ and upgrade since packages.list is
	# maintained by OxeeLi GitHub repos it sould be fine.
	for pkg in $(ls $INSTALLED_PKGS); do
		source ${INSTALLED_PKGS}/${pkg}/pkg.conf
		available="$(grep "^${pkg}|" ${PKGS_LIST} | cut -d "|" -f 2)"
		if [ -n "$available" ] && [ "$version" != "$available" ]; then
			echo -e "$pkg ${CYAN}$version${NC} --> ${GREEN}$available${NC}"
			# We want to upgrade SLi at first
			if [ "$pkg" == "sli" ]; then
				upgrades="$pkg $upgrades"
			else
				upgrades="$ugrades $pkg"
			fi
		fi
		unset version available
	done

	# Offer to upgarde all packages
	nb=$(echo ${upgrades} | wc -w)
	if [ "$nb" -gt "0" ]; then
		echo ""
		read -p "Do you wich to upgrade $nb packages ? (yes/no) " up
		if [ "$up" == "yes" ]; then
			echo ""
			for pkg in ${upgrades}; do
				if [ $(declare -F ${pkg}_install) ]; then
					${pkg}_install
				fi
			done
		fi
	else
		echo -e "${CYAN}Packages are up-to-date.${NC}"
	fi
}

# Remove system files keep config/data in ~/.*
pkg_remove() {
	local pkg="$1"
	[ -d ${INSTALLED_PKGS}/${pkg} ] || error "Can't find package: ${RED}$pkg${NC}"
	print_header "‚ö°Ô∏è Removing package: $pkg"
	for file in $(cat ${INSTALLED_PKGS}/${pkg}/files.list); do
		echo " * Removing: $file"
		sudo rm -rf ${file}
	done
	# Disable any enabled systemd boot symlink
	service_check "$pkg" "$pkg"
	if [ -L "/etc/systemd/system/multi-user.target.wants/${service}.service" ]; then
		echo " * Removing: systemd boot time unit symlink..."
		sudo systemctl disable ${service} 2>/dev/null # Be quit for nice SLi output
	fi
	rm -rf ${INSTALLED_PKGS}/${pkg}
	log_action "Removed package: $pkg"
	print_separator
}

# Initialize a node, tool, package
init() {
	PKG_NAME="$2"
	PKG_DATA=${INSTALLED_PKGS}/${2}
	
	case "$2" in
		wallet) wallet_init "--header" ;;
		"") sli_init ;;
		*)
			# Don't run pkgname_init() if not installed
			if [ ! -d "${INSTALLED_PKGS}/${2}" ]; then
				error "${RED}${2}${NC} must be installed before initialization"
			fi
			pkg_source_recipe "$2"
			if [ $(declare -F ${2}_init) ]; then
				${2}_init 
				print_separator 
			else
				echo -e "No init function available for: ${CYAN}$2${NC}"
			fi ;;
	esac
}

#
# --- Developers Tools ---
#

sli_testsuite() {
	print_header "‚ö°Ô∏è SLi Testsuite"
	echo -e "Colors: ${PURPLE}purple${NC} ${CYAN}cyan${NC} ${YELLOW}yellow${NC} ${RED}red${NC} ${GREEN}green${NC}"
	echo -n "pkg_get_version sli: "; pkg_get_version sli
	if [ -f "debug_recipe.sh" ]; then
		echo ""
		pkg_install "debug"
		echo ""
		pkg_remove "debug"
	fi
}

sli_gen_recipes_sum() {
	if [ -d "recipes" ]; then
		echo -e "Generating recipes sum: ${YELLOW}recipes.sha512${NC}"
		sha512sum recipes/* > recipes.sha512
	else
		error "You must be in SLi source directory"
	fi
}

# Handle channel commands
chan() {
	case "$2" in
		open) chan_open ;;
		close) chan_close ;;
		list) chan_list ;;
		*) chan_usage ;;
	esac
}

# Handle fees commands
fees() {
	case "$2" in
		check) fees_check "$3" ;;
		'set') fees_set ;;
		adjust) fees_adjust ;;
		bump) fees_bump ;;
		*) fees_usage ;;
	esac
}

# Handle Wallet commands
wallet() {
	case "$2" in
		init) wallet_init "--header" ;;
		logs) sli_logs ;;
		new) wallet_new_address ;;
		send) wallet_send_onchain ;;
		lsa|lsaddr|list-addresses) wallet_list_addresses ;;
		bal|balance) wallet_balance ;;
		inv|invoice) wallet_invoice ;;
		qri|qr-invoice) wallet_qr_invoice ;;
		rqr|remove-qr) wallet_remove_qr_invoice ;;
		pay|pay-invoice) wallet_pay_invoice ;;
		*) wallet_usage ;;
	esac
}

#
# --- Handle Top Level Commands ---
#

handle_command() {
	case "$1" in

		version|--version) sli_version ;;
		init) init ${@} ;;
		start) service_start ${@} ;;
		stop) service_stop ${@} ;;
		rs|restart) service_restart ${@} ;;
		sc|show-config) config_show ${2} ;;
		ed|edit) config_edit ${2} ;;
		lg|logs) 
			case "$2" in
				sli|wallet|node|packages) sli_logs ;;
				*) service_logs ${@} ;;
			esac ;;
		st|status) service_status ${@} ;;
		# --- Node ---
		nh|node-health) node_health ;;
		sign) sign_message ;;
		connect) peer_connect ;;
		disconnect) peer_disconnect ;;
		peers) peers_list ;;
		chan) chan ${@} ;;
		fees) fees ${@} ;;
		# --- Tools ---
		m2h|macaroon-to-hex) macaroon_to_hex ${2} ;;
		gpw|gen-passwords) passwords_change ${@} ;;
		nb|node-backup) node_backup ;;
		nr|node-restore) node_backup_restore ${@} ;;
		ne|node-extract) node_backup_extract ${@} ;;
		sec|security-check) security_check ;;
		ping-amboss) ping_amboss ;;
		wa|wallet) wallet ${@} ;;
		# --- Packages manager ---
		ls|list) pkgs_list ;;
		'in'|install) pkg_install ${2} ;;
		up|upgrade) pkgs_upgrade ;;
		gr|get-recipe) pkg_get_recipe "get" ${2} ;;
		rm|remove) pkg_remove ${2} ;;
		cc|clean-cache)
			echo "Removing cache directory content..."
			rm -rf ${CACHE_DIR}/* ;;
		# --- Developers Tools ---
		testsuite) sli_testsuite ;;
		grs|gen-recipes-sum) sli_gen_recipes_sum ;;
		*) usage ;;
	esac
}

# Let's have default empty line for all actions
echo ""
handle_command ${@}
echo ""
exit 0
