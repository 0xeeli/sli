#!/bin/bash
#
# Simply Lightning - A versatile shell utility that simplifies Bitcoin
# Lightning Network packages management while offering a suite of handy
# tools for seamless node operations.
#
# (c) 2025 0xeeLi ‚ö°Ô∏è MIT License
#
sli_version="v0.1.0"

# -- Default Lightning paths (Sli dont use --lit-dir=, default is fine)

LIT_DIR="$HOME/.lit"
LIT_CONF="$LIT_DIR/lit.conf"
LND_DIR="$HOME/.lnd"
LND_CONF="$LND_DIR/lnd.conf"
ALBY_CONF="/etc/systemd/system/albyhub.service" # Use Environment=

# --- Configurable Variables - Can be in a custom sli.conf ---

SLI_DIR="$HOME/.sli"
SLI_CONF="$SLI_DIR/sli.conf"
WALLET_PASS="$LND_DIR/wallet.pass"
BACKUP_DIR="$HOME/sli-backup"
INVOICE_DIR="$HOME/sli-invoice"
EDITOR="nano"

# Load optional custom SLi config file
[ -f "$SLI_CONF" ] && source ${SLI_CONF}

# --- Global Variables ---

INSTALLED_PKGS=${SLI_DIR}/packages
CACHE_DIR=${SLI_DIR}/cache
PKGS_LIST=${SLI_DIR}/packages.list
PKGS_URL="https://raw.githubusercontent.com/0xeeli/sli/refs/heads/main/packages.list"

# Log files for SLi Wallet and Node actions
SLI_LOG=${SLI_DIR}/sli.log

# Node Backup
TMP_BACKUP_DIR="$BACKUP_DIR/tmp"
EXTRACTED_DIR="$BACKUP_DIR/extracted"

# Colors
PURPLE='\033[1;35m'
CYAN='\033[1;36m'
YELLOW='\033[0;33m'
RED='\033[1;31m'
GREEN='\033[1;32m'
NC='\033[0m' # No color

# Emoji: üîå ‚ö°Ô∏è ‚úò üîí üí∞ üîó

#
# --- Helper Functions ---
#

# Display usage instructions (ident with space)
usage() {
	cat << EOT
Usage: $(basename $0) [command|tool] [pkg|arg] [arg]
$(print_separator)
$(echo -e "${YELLOW}Commands:${NC}")
  init               Initialize: sli lit wallet
  start              Start a daemon: litd
  stop               Stop a daemon: litd
  rs|restart         Restart a daemon: litd
  sc|show-config     Display config file: lit.conf
  ed|edit            Edit a config file: lit.conf
  lg|logs            Show last logs for a service (default: 30 lines)
  st|status          Show service status

$(echo -e "${YELLOW}Node Manager:${NC}")
  nh|node-health     Node Health Check (Status, blocks, peers)
  sign               Sign message with your node private key
  connect            Connect to a remote peer
  chan               Channel management (open, close, list)
  fees               Fee management (check, set, adjust, bump)

$(echo -e "${YELLOW}Tools:${NC}")
  m2h|macaroon-hex   Get the HEX format of a macaroon
  gpw|gen-passwords  Gen new passwords for the wallet and Lit UI
  nb|node-backup     Backup and encrypt your node (wallet include)
  nr|node-restore    Restore a GPG encrypted backup file
  ne|node-extract    Extract a GPG encrypted backup file
  sec|security-check Check files permissions created by SLi
  wa|wallet          Run 'sli wa' for wallet operations

$(echo -e "${YELLOW}Packages Manager:${NC}")
  in|install         Install a package
  up|upgrade         Upgrade installed packages
  ls|list            List installed and available packages
  cc|clean-cache     Remove downloaded packages tarball
  rm|remove          Remove a package
EOT
}

# Wallet usage
wallet_usage() {
	cat << EOT
Usage: $(basename $0) [wa|wallet] [command]
$(print_separator)
  init                Initialize the wallet if none exists
  logs                View Wallet logs
  new                 Create a ‚ÇøTC onchain address
  send                Send ‚ÇøTC onchain
  lsa|list-addresses  List onchain wallet addresses
  bal|balance         Wallet balance
  inv|invoice         Generate a Lightning invoice
  qri|qr-invoice      Generate a Lightning QR invoice
  rqr|remove-qr       Remove latest QR invoice files
  pay|pay-invoice     Pay a Lightning invoice
EOT
}

# Channel usage
chan_usage() {
	cat << EOT
Usage: $(basename $0) chan [command]
$(print_separator)
  open        Open a Lightning channel (prompts for node ID and amount)
  close       Close a Lightning channel (cooperative or forced)
  list        List open Lightning channels with details
EOT
}

# Fees usage
fees_usage() {
	cat << EOT
Usage: $(basename $0) fees [command]
$(print_separator)
  check       Check current fee policies (optional: <channel_point>)
  set         Set fees interactively (global or specific channel)
  adjust      Adjust fees dynamically based on traffic or balance
  bump        Speed up a transaction (enter TX id and new sat/vB)
EOT
}

sli_version() { echo "SLi version: $sli_version"; }

# Try to make pretty outputs!
print_separator() {
	echo -e "${PURPLE}--------------------------------------------------------------------------------${NC}"
}

# Check if a command is available
check_command() {
	if ! command -v "$1" >/dev/null 2>&1; then
		echo -e " ‚úò Error: ${RED}$1${NC} is required but not installed."
		echo " * Try: sudo apt install <pkg>  # On Debian/Ubuntu"
		echo " * Try: sli install <pkg>  # If it's a Lightning package"
		echo "" && exit 1
	fi
}

# Log events for SLi. Rotate log if file exceeds 1MB
log_action() {
	echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$SLI_LOG"
	if [ $(stat -c %s "$SLI_LOG") -gt 1048576 ]; then
		mv -f "$SLI_LOG" "${SLI_LOG}.old"
		touch "$SLI_LOG"
	fi
}

#
# --- Core Functions ---
#

# Should be run at first usage - Self install ;-)
sli_init() {
	pkg="sli"
	echo "‚ö°Ô∏è SLi Initialization"
	print_separator
	echo -e "Creating data structure in: ${YELLOW}$SLI_DIR${NC}"
	mkdir -p ${INSTALLED_PKGS}/${pkg} ${CACHE_DIR}
	echo -e "Storing curent SLi version: ${CYAN}$sli_version${NC}"
	echo "version=\"$sli_version\"" > ${INSTALLED_PKGS}/${pkg}/pkg.conf
	
	echo -e " * Installing SLi: /usr/local/bin/${pkg}"
	sudo cp -f ${0} /usr/local/bin 2>/dev/null
	echo "/usr/local/bin/sli" >  ${INSTALLED_PKGS}/${pkg}/files.list
	
	# Install bash completion if you init from sli src
	if [ -f "sli-bash-completion.sh" ]; then
		comp="/usr/share/bash-completion/completions/sli"
		echo " * Installing SLi bash completion..."
		sudo cp -f sli-bash-completion.sh ${comp}
		echo "$comp" >> ${INSTALLED_PKGS}/${pkg}/files.list
	fi
	
	[ -f "$PKGS_LIST" ] || pkgs_get_list
	# Create an empty sli.conf to let user customize some variables/paths
	if [ ! -f "$SLI_CONF" ]; then
		echo "# sli.conf: SLi configuration file" > ${SLI_CONF}
	fi
	print_separator
}

# View Sli Wallet and Node logs
sli_logs() {
	echo "‚ö°Ô∏è SLi Packages, Wallet and Node Logs"
	print_separator
	cat ${SLI_LOG}
	print_separator
}

# Used for upgrade, we keep main branch for now since we have control
# on packages.list to modify versions.
sli_install() {

	PKG_NAME="sli"
	SRC_URL="https://github.com/0xeeli/sli/releases/download"
	PKG_VERSION="$(pkg_get_version $PKG_NAME)"
	TARBALL="${PKG_NAME}-${PKG_VERSION}.tar.gz"
	SRC_DIR="${PKG_NAME}-${PKG_VERSION}"
	DL_URL=${SRC_URL}/${PKG_VERSION}/${TARBALL}

	# Pre install
	pkg_pre_install "sli" "$PKG_VERSION"
	pkg_download_tarball
	pkg_extract_tarball

	# Install to /usr/local/bin
	echo -e "${CYAN}Install path: /usr/local/bin${NC}"
	echo " * Installing: sli"
	sudo cp -f ${SRC_DIR}/${PKG_NAME} /usr/local/bin
	echo "/usr/local/bin/sli" > ${PKG_DATA}/files.list
	
	# Install bash completion
	comp="/usr/share/bash-completion/completions/sli"
	echo " * Installing SLi bash completion..."
	sudo cp -f sli-bash-completion.sh ${comp}
	echo "$comp" >> ${INSTALLED_PKGS}/${pkg}/files.list

	# Post install
	pkg_post_install
}

# Let user use lit in place of litd. also used to check file exist (ie litd.service)
service_check() {
	if [ -z "$2" ]; then
		echo " ‚úò Missing service name. Usage: sli $1 <service>"
		echo "" && exit 1
	fi
	case "$2" in
		lit|loop|pool) service="${2}d" ;;
		*) service="$2" ;;
	esac
}

service_start() {
	service_check "$@" || return 1
	if [ "$(systemctl is-active ${service})" != "active" ]; then
		echo "‚ö°Ô∏è Starting $service service..."
		sudo systemctl start ${service}
	else
		echo "‚ö°Ô∏è $service service is active."
	fi
	wallet_db_exist
}

service_stop() {
	service_check "$@" || return 1
	if [ "$(systemctl is-active ${service})" == "active" ]; then
		echo "‚ö°Ô∏è Stopping $service service..."
		sudo systemctl stop ${service}
	else
		echo "‚ö°Ô∏è $service service is not active."
	fi
}

service_restart() {
	service_check "$@" || return 1
	echo "‚ö°Ô∏è Restarting $service service..."
	# sudo systemctl restart ${service} : Not always working with litd
	sudo systemctl stop ${service}
	sleep 2
	sudo systemctl start ${service}
	wallet_db_exist
}

# View service/daemon logs
service_logs() {
	local lines="${3:-30}"
	service_check ${@}
	echo -e "‚ö°Ô∏è Showing last $lines lines of logs for: ${CYAN}${service}${NC}"
	print_separator
	journalctl -q -u "$service" -n "$lines" --no-pager
	print_separator
}

# View service/daemon status
service_status() {
	service_check ${@}
	echo -e "‚ö°Ô∏è Service status for: ${CYAN}${service}${NC}"
	print_separator
	script -q -c "systemctl status ${service} --no-pager" /dev/null | sed '/^\s*‚îî‚îÄ/q'
	stty sane # Restore terminal settings
	print_separator
}

# Used by package install to generate a secure systemd unit
config_service_unit() {
	service_unit="${1}.service"
	service_desc="$2"
	if [ ! -f /etc/systemd/system/${service_unit} ]; then
		echo -e "${CYAN}Creating systemd service file:${NC} ${service_unit}"
		cat << EOF | sudo tee /etc/systemd/system/${service_unit} > /dev/null
[Unit]
Description=${service_desc}
After=network.target

[Service]
ExecStart=/usr/local/bin/${1}
User=$USER
Type=simple
Restart=always
RestartSec=60
LimitNOFILE=8192
PrivateTmp=true
ProtectSystem=strict
NoNewPrivileges=true
MemoryDenyWriteExecute=true
AmbientCapabilities=CAP_NET_BIND_SERVICE

[Install]
WantedBy=multi-user.target
EOF
		# Track installed file
		echo "/etc/systemd/system/${service_unit}" >> ${PKG_DATA}/files.list
		sudo systemctl daemon-reload
		read -p "Do you wish to start $1 on each boot ? (yes/no) " enable
		if [ "$enable" == "yes" ]; then
			echo "Enabling $1 on boot time..."
			sudo systemctl enable ${1} 2>/dev/null
		fi
	fi
}

# Show config file if any
config_show_file() {
	if [ ! -f "$1" ]; then
		echo " ‚úò No config file found. Try 'sli init <pkg>' to initialize."
	else
		cat "$1"
	fi
}

# Set config file path
config_show() {
	if [ ! -n "$1" ]; then
		echo -e "Usage: $(basename $0) show-config <pkg>\n" && exit 0
	fi
	echo -e "‚ö°Ô∏è Configuration file for: ${CYAN}$1${NC}"
	print_separator
	case "$1" in
		albyhub|alby) config_show_file "$ALBY_CONF" ;;
		lit) config_show_file "$LIT_CONF" ;;
		lnd) config_show_file "$LND_CONF" ;;
		sli) config_show_file "$SLI_CONF" ;;
		*) echo -e " ‚úò No config file for: ${RED}$1${NC}" ;;
	esac
	print_separator
}

# Edit config if any. User can customize EDITOR with ~/.sli/sli.conf
config_edit_file() {
	if [ ! -f "$1" ]; then
		echo " ‚úò No config file found: Try 'sli init <pkg>' to initialize."
	else
		case "$1" in
			*.service) sudo ${EDITOR} ${1} ;;
			*) ${EDITOR} ${1} ;;
		esac
	fi
}

# Set config file path for editing
config_edit() {
	if [ ! -n "$1" ]; then
		echo -e "Usage: $(basename $0) edit <pkg>\n" && exit 0
	fi
	case "$1" in
		albyhub|alby) # We use systemd unit to configure Alb Hub
			config_edit_file "$ALBY_CONF"
			echo "Reloading systemd configuration..."
			sudo systemctl daemon-reload ;;
		lit) config_edit_file "$LIT_CONF" ;;
		lnd) config_edit_file "$LND_CONF" ;;
		sli) config_edit_file "$SLI_CONF" ;;
		*) echo " ‚úò No config file for: $1" ;;
	esac
}

# We check the files created by SLi
security_check() {
	echo "‚ö°Ô∏è Security Check on SLi-Created Files"
	print_separator
	user=$(whoami)

	# List of files to check
	files=(
		"$WALLET_PASS"
		"$SLI_CONF"
		"$LIT_CONF"
		"$LND_CONF"
		#"$LND_DIR/data/chain/bitcoin/mainnet/admin.macaroon"
		"$BACKUP_DIR"/*.gpg
	)

	for file in "${files[@]}"; do
		# Handle glob expansion for backups
		if [[ "$file" == "$BACKUP_DIR"/*.gpg ]]; then
			if ! ls $file >/dev/null 2>&1; then
				continue  # Skip if no backups exist
			fi
		fi
		# Ensure file exists before checking
		if [ -f "$file" ]; then
			echo -e "Checking: ${YELLOW}$(basename "$file")${NC}"
			local perms=$(stat -c %a "$file")
			local owner=$(stat -c %U "$file")
			# Check permissions (should be 0600)
			if [ "$perms" != "600" ]; then
				echo -e " --> Permissions: ${RED}$perms${NC} (should be 0600)"
				read -p "Fix permissions to 0600? (yes/no): " fix
				if [ "$fix" == "yes" ]; then
					chmod 0600 "$file"
					echo "  ‚úî Fixed permissions to: 0600"
				fi
			else
				echo -e " --> Permissions: ${GREEN}0600${NC}"
			fi
			# Check ownership
			if [ "$owner" != "$user" ]; then
				echo -e " --> Owner: ${RED}$owner${NC} (should be $user)"
				read -p "Change owner to $user? (yes/no): " fix
				if [ "$fix" == "yes" ]; then
					chown "$user" "$file"
					echo "  ‚úî Fixed owner to $user"
				fi
			else
				echo -e " --> Owner: ${GREEN}$user${NC}"
			fi
			echo ""
		fi
	done
	print_separator
}

# Sing a message in interactive mode by the node‚Äôs identity private key
sign_message() {
	echo "üí¨ Sing a message"
	print_separator && echo ""
	read -p "Message to sing: " message
	echo -e "\n${CYAN}Signature:${NC}\n"
	if [ -n "$message" ]; then
		lncli signmessage "$message" | jq -r '.signature'
	fi
	echo "" && print_separator
}

# Connect to a remote peer
peer_connect() {
	echo "‚ö°Ô∏è Connect to a peer: <pubkey>@IP:port"
	print_separator
	echo ""
	read -p "Peer: " peer
	[ -n "$peer" ] && lncli connect ${peer}
}

#
# --- Wallet Tools and Functions ---
#

# Create a wallet if none
wallet_init() {
	if [ "$1" == "--header" ]; then
		echo "‚ö°Ô∏è Wallet Initialization"
		print_separator
	fi
	if [ ! -f "$LND_DIR/data/chain/bitcoin/mainnet/wallet.db" ]; then
		echo -e "Launching: ${GREEN}lncli create${NC}"
		echo "üîí Paste your generated or own Wallet password"
		echo ""
		lncli create
	else
		echo "A wallet database already exist:"
		echo -e " --> ${YELLOW}$LND_DIR/data/chain/bitcoin/mainnet/wallet.db${NC}"
	fi
}

wallet_info() {
	if [ "$(lncli state | grep LOCKED)" ]; then
		echo "üîí Wallet is locked."
	else
		echo "üîì Wallet is unlocked."
	fi
}

# Used by: service_start and service_restart (litd or lnd)
wallet_db_exist() {
	case "$service" in
		litd|lnd)
			if [ ! -f "$LND_DIR/data/chain/bitcoin/mainnet/wallet.db" ]; then
				echo "üîí No wallet.db file found."
				return 1
			fi ;;
		cln)
			# If Core lighning is implemented ;-)
			echo "Core lighning" ;;
	esac
}

# Create a new onchain wallet
wallet_new_address() {
	check_command "jq"
	echo "‚ö°Ô∏è New ‚ÇøTC Address for onchain funds (p2wkh)"
	print_separator
	addr=$(lncli newaddress p2wkh | jq -r '.address')
	if [ -n "$addr" ]; then
		echo "New ‚ÇøTC address: $addr"
		log_action "Created BTC onchain address: $addr"
	else
		echo -e "${RED}Is your litd or lnd daemon running and wallet unlocked ?${NC}"
	fi
	print_separator
}

# Parse JSON output with jq to nicely display wallet(s) and show balance(s)
wallet_list_addresses() {
	check_command "jq"
	echo "‚ö°Ô∏è Onchain ‚ÇøTC Addresses"
	print_separator
	# Exclude addresses without funds ?
	#lncli wallet addresses list | jq -r '.account_with_addresses[].addresses[] | select(.balance != "0") | "\(.address) \(.balance)"'
	lncli wallet addresses list | jq -r '.account_with_addresses[].addresses[] | "\(.address) \(.balance)"'
	print_separator
}

wallet_balance() {
	check_command "jq"
	echo "‚ö°Ô∏è Wallet Balances"
	print_separator
	echo "On-chain Balance:"
	lncli walletbalance | jq -r '"\(.confirmed_balance) sat (confirmed) / \(.unconfirmed_balance) sat (unconfirmed)"'
	echo -e "\nChannel Balance:"
	lncli channelbalance | jq -r '"\(.balance) sat (local) / \(.remote_balance.sat) sat (remote)"'
	print_separator
}

# Let send some sats
wallet_send_onchain() {
	echo "üí∞ Send ‚ÇøTC Onchain (Amount in sat)"
	print_separator && echo ""
	read -p "Address: " addr
	read -p "Amount : " amt
	if [[ ! "$amt" =~ ^[0-9]+$ ]]; then
		echo " ‚úò Invalid amount: $amt Must be numeric."
		return 1
	fi
	if [ -n "$addr" ] && [ -n "$amt" ]; then
		lncli sendcoins --addr="$addr" --amount="$amt"
		log_action "Sent $amt sats to $addr"
	else
		echo " ‚úò Address or amount missing."
	fi
}

wallet_invoice_check() {
	if [ -z "$invoice" ]; then
		echo -e "\n ‚úò Failed to generate invoice. Is your node running and wallet unlocked ?\n"
		exit 1
	fi
}

# Generate interactively a Lightning invoice
wallet_invoice() {
	check_command "jq"
	echo "‚ö°Ô∏è Generate Lightning Invoice"
	print_separator
	echo ""
	read -p "Amount (sat, default: 1000): " amt
	amt=${amt:-1000}
	read -p "Memo (optional): " memo
	if [[ ! "$amt" =~ ^[0-9]+$ ]]; then
		echo " ‚úò Invalid amount: $amt. Must be numeric."
		return 1
	fi
	wallet_invoice_check

	# Display invoice
	if [ -n "$memo" ]; then
		invoice=$(lncli addinvoice --amt="$amt" --memo="$memo" | jq -r '.payment_request')
		log_action "Generated invoice for: $amt sat with memo $memo"
	else
		invoice=$(lncli addinvoice --amt="$amt" | jq -r '.payment_request')
		log_action "Generated invoice for: $amt"
	fi
	echo -e "${CYAN}Invoice:${NC} $invoice\n"
	print_separator
}

# Generate an invoice and save QR code + text so we can display the invoice
# from a CGI|PHP page or static html page (manually or generated by a script if no CGI)
wallet_qr_invoice() {
	check_command "jq"
	check_command "qrencode"
	local invoice_qr="${INVOICE_DIR}/invoice.png"
	local invoice_file="${INVOICE_DIR}/invoice.txt"

	echo "‚ö°Ô∏è Generate Lightning Invoice with QR Code"
	print_separator
	echo ""
	read -p "Amount (sat, default: 1000): " amt
	amt=${amt:-1000}
	read -p "Memo (optional): " memo
	if [[ ! "$amt" =~ ^[0-9]+$ ]]; then
		echo -e "\n ‚úò Invalid amount: $amt. Must be numeric."
		return 1
	fi

	# Generate invoice
	if [ -n "$memo" ]; then
		invoice=$(lncli addinvoice --amt="$amt" --memo="$memo" | jq -r '.payment_request')
		log_action "Generated QR invoice for: $amt sat with memo $memo"
	else
		invoice=$(lncli addinvoice --amt="$amt" | jq -r '.payment_request')
		log_action "Generated QR invoice for: $amt sat"
	fi
	wallet_invoice_check

	# Ensure output dir exists
	mkdir -p "$INVOICE_DIR"

	# Generate QR code PNG
	qrencode -o "$invoice_qr" -s 6 "$invoice"
	if [ $? -ne 0 ]; then
		echo " ‚úò Failed to generate QR code."
		return 1
	fi

	# Save invoice text
	echo "Invoice: $invoice" > "$invoice_file"
	echo "Amount : $amt sat" >> "$invoice_file"
	[ -n "$memo" ] && echo "Memo   : $memo" >> "$invoice_file"

	echo -e "${CYAN}Invoice:${NC} $invoice"
	echo -e "${YELLOW}QR Code saved to:${NC} $invoice_qr"
	echo ""
	print_separator
}

# Manually delete invoice.png and invoice.txt, ca be done via CGI too
wallet_remove_qr_invoice() {
	echo "üí∏ Remove QR Invoice"
	print_separator
	echo "Removing latest invoice files..."
	rm -f ${INVOICE_DIR}/*
}

# Pay a Lightning invoice directly
wallet_pay_invoice() {
	check_command "jq"
	echo "üí∏ Pay a Lightning Invoice"
	print_separator
	echo ""
	read -p "Invoice (bolt11): " invoice
	if [ -n "$invoice" ]; then
		lncli payinvoice "$invoice"
	else
		echo " ‚úò No invoice provided"
	fi
	echo ""
	print_separator
}

#
# --- Channel functions ---
#

# Open a channel
chan_open() {
	echo "üîó Open a Channel (Amount in sat)"
	print_separator && echo ""
	read -p "Node ID: " node
	read -p "Amount : " amt
	read -p "Fee rate (sats/vB): " fee
	# ensure fast transactions here or/and in lit.conf
	# lnd.bitcoin.feerate=5
	if [ -n "$node" ] && [ -n "$amt" ] && [ -n "$fee" ]; then
		lncli openchannel --node_key="$node" --local_amt="$amt" --sat_per_vbyte="$fee" || exit 1
		log_action "Opened channel with $node for: $amt sats"
	fi
}

# Close a channel cooperatively or forced
chan_close() {
	check_command "jq"
	echo "üîó Close a Lightning Channel"
	print_separator
	echo "Open channels:"
	lncli listchannels | jq -r '.channels[] | "Peer: \(.remote_pubkey) | Chan ID: \(.channel_point)"'
	echo ""
	read -p "Channel Point (e.g., txid:output): " chan_point
	read -p "Force close? (yes/no, default: no): " force
	force=${force:-no}
	if [ "$force" == "yes" ]; then
		lncli closechannel --force "$chan_point"
		log_action "Force-closed channel: $chan_point"
	else
		lncli closechannel "$chan_point"
		log_action "Cooperatively closed channel: $chan_point"
	fi
	print_separator
}

# List open channels
chan_list() {
	check_command "jq"
	echo "üîó Open Lightning Channels"
	print_separator
	lncli listchannels | jq -r '.channels[] | "Peer: \(.remote_pubkey)\nCapacity: \(.capacity) sat | Local: \(.local_balance) sat | Active: \(.active)"'
	print_separator
}

#
# --- Fees functions ---
#

# Check the current fees policy
fees_check() {
	check_command "jq"
	echo "‚ö°Ô∏è Current Fee Policies"
	print_separator
	lncli listchannels | jq -r '.channels[].chan_id' | xargs -I{} lncli getchaninfo {} | \
		jq -r '"Channel ID: \(.channel_id) | Base Fee: \(.node1_policy.fee_base_msat // "N/A") msat | Fee Rate: \(.node1_policy.fee_rate_milli_msat // "N/A") ppm"'
	print_separator
}

# Set routing fees
fees_set() {
	check_command "jq"
	check_command "bc"
	echo "‚ö°Ô∏è Set Routing Fees"
	print_separator
	echo "Options:"
	echo " --> Leave blank for global settings (all channels)"
	echo " --> Enter a channel point (e.g., txid:output) for a specific channel"
	echo ""
	read -p "Channel Point (optional): " chan_point
	echo ""
	echo "Suggested starting fees for new nodes:"
	echo " --> Base Fee: 100 msat (0.1 sat)"
	echo " --> Fee Rate: 200 ppm (0.02%)"
	
	echo ""
	read -p "Base Fee (msat, default: 100): " base_fee
	base_fee=${base_fee:-100}
	read -p "Fee Rate (ppm, default: 200): " fee_rate
	fee_rate=${fee_rate:-200}
	if ! [[ "$base_fee" =~ ^[0-9]+$ ]] || ! [[ "$fee_rate" =~ ^[0-9]+$ ]]; then
		echo " ‚úò Invalid input: Base Fee and Fee Rate must be numeric."
		return 1
	fi
	
	fee_rate_decimal=$(echo "scale=6; $fee_rate / 1000000" | bc)
	if [ -z "$chan_point" ]; then
		echo "Applying globally: Base Fee: $base_fee msat | Fee Rate: $fee_rate ppm"
		
		lncli updatechanpolicy --base_fee_msat "$base_fee" --fee_rate "$fee_rate_decimal" \
			--min_htlc_msat 1000 --time_lock_delta 40 | \
			jq -r 'if .failed_updates == [] then "‚úî Fees updated successfully." else "Error occurred" end'
		
		log_action "Set global fees: Base $base_fee msat, Rate $fee_rate ppm"
	else
		echo "Applying to channel $chan_point"
		echo " --> Base Fee: $base_fee msat | Fee Rate: $fee_rate ppm"
		
		lncli updatechanpolicy --base_fee_msat "$base_fee" --fee_rate "$fee_rate_decimal" \
			--chan_point "$chan_point" --min_htlc_msat 1000 --time_lock_delta 40 | \
			jq -r 'if .failed_updates == [] then "‚úî Fees updated successfully." else "Error occurred" end'
		
		log_action "Set fees for channel $chan_point: Base $base_fee msat, Rate $fee_rate ppm"
	fi
	print_separator
}

# Dynamically adjust fees
fees_adjust() {
	check_command "jq"
	echo "‚ö°Ô∏è Dynamically Adjust Fees"
	print_separator
	echo "Select a channel to adjust:"
	lncli listchannels | jq -r '.channels[]| "Channel: \(.channel_point)"'
	#lncli listchannels | jq -r '.channels[]| "Channel: \(.channel_point) | Local: \(.local_balance) sat | Remote: \(.remote_balance.sat)"'
	echo ""
	read -p "Channel Point: " chan_point
	if [ -z "$chan_point" ]; then
		echo " ‚úò Please specify a channel point."
		return 1
	fi
	current_base=$(lncli getchaninfo "$(lncli listchannels | jq -r ".channels[] | select(.channel_point == \"$chan_point\") | .chan_id")" | jq -r '.policy1.fee_base_msat')
	current_rate=$(lncli getchaninfo "$(lncli listchannels | jq -r ".channels[] | select(.channel_point == \"$chan_point\") | .chan_id")" | jq -r '.policy1.fee_rate_ppm')
	echo "Current: Base Fee: $current_base msat | Fee Rate: $current_rate ppm"
	echo ""
	echo -e "${CYAN}Adjustment options:${NC}"
	echo " --> Lower fees to boost traffic (e.g., halve current fees)"
	echo " --> Raise fees to increase earnings or slow outbound liquidity drain"
	echo ""
	read -p "Action (lower/raise): " action
	
	case "$action" in
		lower)
			new_base=$((current_base / 2))
			new_rate=$((current_rate / 2)) ;;
		raise)
			new_base=$((current_base + 50))
			new_rate=$((current_rate + 100)) ;;
		*)
			echo " ‚úò Invalid action. Use 'lower' or 'raise'."
			return 1 ;;
	esac
	new_rate_decimal=$(echo "scale=6; $new_rate / 1000000" | bc)
	echo "Applying: Base Fee: $new_base msat | Fee Rate: $new_rate ppm"
	
	lncli updatechanpolicy --base_fee_msat "$new_base" --fee_rate "$new_rate_decimal" \
		--chan_point "$chan_point" --min_htlc_msat 1000 --time_lock_delta 40
	log_action "Adjusted fees for $chan_point: Base $new_base msat, Rate $new_rate ppm ($action)"
	echo "‚úî Fees adjusted successfully."
	print_separator
}

# Speed up a transaction
fees_bump() {
	echo "‚ö°Ô∏è Bump (speed up) a transaction"
	print_separator
	echo "Make sure your transaction is flaged RBF (Replace-by-fee)"
	echo ""
	read -p "TX id: " tx
	read -p "New sat/vB: " spb
	[ -n "$tx" ] || exit 0
	[ -n "spb" ] || exit 0
	lncli wallet bumpfee --sat_per_byte ${spb} ${tx}:0
}

#
# --- Packages function: init + install + config files ---
#

# Basic and working lit.conf to get started
lit_config_file() {
	cat << EOT
#
# LiTd Settings: lit.conf
#
uipassword=
lnd-mode=integrated

#
# LND Settings
#

# Wallet
#lnd.wallet-unlock-password-file=${WALLET_PASS}
#lnd.wallet-unlock-allow-create=true

# Set a nice name for your node
lnd.alias=SLiNode

# Optional URL for external fee estimation.
lnd.feeurl=https://nodes.lightning.computer/fees/v1/btc-fee-estimates.json

# Used by Lit UI
lnd.rpcmiddleware.enable=true

#
# Bitcoin Configuration
#

# Use a neutrino light back-end so we don't need a full ‚Çø node.
lnd.bitcoin.node=neutrino

# Connect to mainnet
lnd.bitcoin.mainnet=1
lnd.bitcoin.active=1

# The seed DNS server(s) to use for initial peer discovery.
lnd.bitcoin.dnsseed=nodes.lightning.directory,soa.nodes.lightning.directory
EOT
}

# Lightning Terminal install function
lit_install() {

	PKG_NAME="lit"
	SRC_URL="https://github.com/lightninglabs/lightning-terminal/releases/download"
	PKG_VERSION="$(pkg_get_version $PKG_NAME)"
	TARBALL="lightning-terminal-linux-amd64-${PKG_VERSION}.tar.gz"
	SRC_DIR="lightning-terminal-linux-amd64-${PKG_VERSION}"
	DL_URL=${SRC_URL}/${PKG_VERSION}/${TARBALL}

	# Pre install
	pkg_pre_install "lit" "$PKG_VERSION"
	pkg_download_tarball
	pkg_extract_tarball

	# Install to /usr/local/bin
	echo -e "${CYAN}Install path: /usr/local/bin${NC}"
	for bin in $(ls $SRC_DIR); do
		# Handle conflict with loop, pool and friends
		if [ ! -d ${INSTALLED_PKGS}/${bin} ]; then
			echo " * Installing: $bin"
			sudo cp -f ${SRC_DIR}/${bin} /usr/local/bin
			echo "/usr/local/bin/$bin" >> ${PKG_DATA}/files.list
		else
			echo -e " ! Skipping  : ${RED}$bin${NC}"
		fi
	done

	# Systemd service
	config_service_unit "litd" "Lightning Terminal (LiT)"
	pkg_post_install
}

# Initialize LiTd
lit_init() {
	check_command "litd"
	echo "‚ö°Ô∏è Lit Initialization"
	print_separator
	if [ ! -f "$LIT_CONF" ]; then
		echo -e "Creating config file: ${YELLOW}$LIT_CONF${NC}"
		mkdir -p ${HOME}/.lit && touch ${LIT_CONF}
		lit_config_file > ${LIT_CONF}
		echo "Setting secure permissions: read only by $USER (0600)"
		chmod 0600 ${LIT_CONF}
	else
		echo -e "Config file already exist:"
		echo -e " --> ${YELLOW}$LIT_CONF${NC}"
	fi
	
	# Check if uipassword= is empty and offer to creat random password
	ui_password=$(awk -F= '$1=="uipassword"{print $2}' "$LIT_CONF")
	if [ -z "$ui_password" ]; then
		echo ""
		echo -e "${CYAN}Password for Lit Web UI${NC}"
		read -p "Create a secure password ? (yes/no) " gen_uipassword
		if [ "$gen_uipassword" == "yes" ]; then
			password_init ui-password
		fi
	else
		echo " --> uipassword= is set"
	fi
	
	# We can now start litd and create a Wallet
	echo "" && service_start "start" "litd"
	if [ ! -f "$LND_DIR/data/chain/bitcoin/mainnet/wallet.db" ]; then
		echo ""
		echo -e "${CYAN}Wallet Creation${NC}"
		# Create or use existing wallet password
		if [ ! -f "$WALLET_PASS" ]; then
			read -p "Create a secure password ? (yes/no) " gen_walletpass
			if [ "$gen_walletpass" == "yes" ]; then
				password_init wallet-password
			fi
		else
			echo "Found existing Wallet password:"
			echo -e " --> ${YELLOW}$WALLET_PASS${NC}"
			echo " --> $(cat $WALLET_PASS)"
			echo ""
		fi
		# Now we can initialze wallet
		wallet_init
	else
		echo "üîí Found Wallet database"
		echo -e " --> ${YELLOW}$WALLET_PASS${NC}"
	fi
	
	# Wallet auto-unlock
	if [ ! "$(grep ^lnd.wallet-unlock-password-file $LIT_CONF)" ]; then
		echo ""
		echo -e "${CYAN}Wallet Auto-unlock${NC}"
		echo "Let litd auto-unlock the wallet on startup (useful)"
		echo ""
		read -p "Do you wish to enable Wallet auto-unlock ? (yes/no) " auto_unlock
		if [ "$auto_unlock" == "yes" ]; then
			echo "Enabling auto-unlock in: $LIT_CONF"
			sed -i 's/#lnd.wallet-unlock-password-file=/lnd.wallet-unlock-password-file=/' "$LIT_CONF"
			sed -i 's/#lnd.wallet-unlock-allow-create=true/lnd.wallet-unlock-allow-create=true/' "$LIT_CONF"
			echo "Restarting litd to apply auto-unlock..."
			service_restart "restart" "litd"
		else
			echo "Edit lit.conf if you want auto-unlock or run again: sli init"
		fi
	else
		echo "Wallet auto-unlock is enabled"
	fi
}

# This pool package provides loop and loopd (deamon). Conflict with Lit
# package, we keep this build.
loop_install() {

	PKG_NAME="loop"
	SRC_URL="https://github.com/lightninglabs/loop/releases/download"
	PKG_VERSION="$(pkg_get_version $PKG_NAME)"
	TARBALL="${PKG_NAME}-linux-amd64-${PKG_VERSION}.tar.gz"
	SRC_DIR="${PKG_NAME}-linux-amd64-${PKG_VERSION}"
	DL_URL=${SRC_URL}/${PKG_VERSION}/${TARBALL}

	# Pre install
	pkg_pre_install "$PKG_NAME" "$PKG_VERSION"
	pkg_download_tarball
	pkg_extract_tarball

	# Install to /usr/local/bin
	echo -e "${CYAN}Install path: /usr/local/bin${NC}"
	echo " * Installing: ${PKG_NAME}"
	sudo cp -f ${SRC_DIR}/${PKG_NAME} /usr/local/bin
	echo " * Installing: ${PKG_NAME}d"
	sudo cp -f "${SRC_DIR}/${PKG_NAME}d" /usr/local/bin

	echo "/usr/local/bin/${PKG_NAME}" > ${PKG_DATA}/files.list
	echo "/usr/local/bin/${PKG_NAME}d" >> ${PKG_DATA}/files.list

	# Pool will conflict with LiT Bundle, prefer this version.
	# loop-mode=disable can be set in lit.conf
	if [ -d ${INSTALLED_PKGS}/lit ]; then
		if grep -q ".*loop" ${INSTALLED_PKGS}/lit/files.list; then
			echo -e " * ${YELLOW}NOTE:${NC} Loop already installed by lit --> Keeping this build"
			sed -i '/^\/usr\/local\/bin\/loop$/d' "${INSTALLED_PKGS}/lit/files.list"
			# Store a backup of 'lit loop' to be restored on loop remove
			#cp -f /usr/local/bin/loop ${${INSTALLED_PKGS}}/lit/loop
		fi
	fi

	# Systemd service
	config_service_unit "loopd" "Loopd Off/On Chain Bridge"

	echo "Documentation: https://lightning.engineering/loop/"

	# Post install
	pkg_post_install
}

# This pool package provides pool and poold (deamon) standalone pool
# provided by LiT don't work properly.
pool_install() {

	PKG_NAME="pool"
	SRC_URL="https://github.com/lightninglabs/pool/releases/download"
	PKG_VERSION="$(pkg_get_version $PKG_NAME)"
	TARBALL="${PKG_NAME}-linux-amd64-${PKG_VERSION}.tar.gz"
	SRC_DIR="${PKG_NAME}-linux-amd64-${PKG_VERSION}"
	DL_URL=${SRC_URL}/${PKG_VERSION}/${TARBALL}

	# Pre install
	pkg_pre_install "$PKG_NAME" "$PKG_VERSION"
	pkg_download_tarball
	pkg_extract_tarball

	# Install to /usr/local/bin
	echo -e "${CYAN}Install path: /usr/local/bin${NC}"
	echo " * Installing: ${PKG_NAME}"
	sudo cp -f ${SRC_DIR}/${PKG_NAME} /usr/local/bin
	echo " * Installing: ${PKG_NAME}d"
	sudo cp -f "${SRC_DIR}/${PKG_NAME}d" /usr/local/bin

	echo "/usr/local/bin/${PKG_NAME}" > ${PKG_DATA}/files.list
	echo "/usr/local/bin/${PKG_NAME}d" >> ${PKG_DATA}/files.list

	# Pool will conflict with LiT Bundle, prefer this version.
	# pool-mode=disable can be set in lit.conf
	if [ -d ${INSTALLED_PKGS}/lit ]; then
		if grep -q ".*pool" ${INSTALLED_PKGS}/lit/files.list; then
			echo -e " * ${CYAN}NOTE:${NC} Pool already installed by lit --> Keeping this build"
			sed -i '/^\/usr\/local\/bin\/pool$/d' "${INSTALLED_PKGS}/lit/files.list"
		fi
	fi

	# Systemd service.
	config_service_unit "poold" "Lightning Pool Daemon"

	echo "Documentation: https://pool.lightning.engineering/"

	# Post install
	pkg_post_install
}

# lndconnect - https://github.com/LN-Zap/lndconnect
lndconnect_install() {

	PKG_NAME="lndconnect"
	SRC_URL="https://github.com/LN-Zap/lndconnect/releases/download/"
	PKG_VERSION="$(pkg_get_version $PKG_NAME)"
	TARBALL="${PKG_NAME}-linux-amd64-${PKG_VERSION}.tar.gz"
	SRC_DIR="${PKG_NAME}-linux-amd64-${PKG_VERSION}"
	DL_URL=${SRC_URL}/${PKG_VERSION}/${TARBALL}

	# Pre install
	pkg_pre_install "$PKG_NAME" "$PKG_VERSION"
	pkg_download_tarball
	pkg_extract_tarball

	# Install to /usr/local/bin
	echo -e "${CYAN}Install path: /usr/local/bin${NC}"
	echo " * Installing: ${PKG_NAME}"
	sudo cp -f ${SRC_DIR}/${PKG_NAME} /usr/local/bin
	echo "/usr/local/bin/${PKG_NAME}" > ${PKG_DATA}/files.list

	# Post install
	pkg_post_install
}

# Alby Hub install
albyhub_install() {

	PKG_NAME="albyhub"
	SRC_URL="https://github.com/getAlby/hub/releases/download"
	PKG_VERSION="$(pkg_get_version $PKG_NAME)"
	TARBALL="${PKG_NAME}-Server-Linux-x86_64.tar.bz2"
	SRC_DIR="${PKG_NAME}-Server-Linux-x86_64"
	DL_URL=${SRC_URL}/${PKG_VERSION}/${TARBALL}

	# Pre install
	pkg_pre_install "albyhub" "$PKG_VERSION"
	pkg_download_tarball
	pkg_extract_tarball

	# Install to /usr/local/bin
	echo -e "${CYAN}Install path: /usr/local/bin${NC}"
	echo " * Installing: ${PKG_NAME}"
	sudo cp -f ${SRC_DIR}/bin/${PKG_NAME} /usr/local/bin
	echo "/usr/local/bin/${PKG_NAME}" > ${PKG_DATA}/files.list
	
	# Install to /usr/local/lib
	for lib in $(ls ${SRC_DIR}/lib); do
		echo " * Installing: $lib"
		sudo cp -f ${SRC_DIR}/lib/${lib} /usr/local/lib
		echo "/usr/local/lib/${lib}" >> ${PKG_DATA}/files.list
	done
	
	# Systemd service
	config_service_unit "${PKG_NAME}" "Alby Hub Server"
	
	# Alby Hub don't use a config file, we need additional startup 
	# environment variables. Let's sed!
	echo "Adding environment variables to: ${PKG_NAME}.service"
	sudo sed -i "/AmbientCapabilities=CAP_NET_BIND_SERVICE/a \
Environment=\"PORT=8029\"\n\
Environment=\"WORK_DIR=$HOME/.albyhub\"\n\
Environment=\"LOG_EVENTS=true\"\n\
Environment=\"LDK_GOSSIP_SOURCE=\"" "/etc/systemd/system/${PKG_NAME}.service"
	sudo systemctl daemon-reload
	pkg_post_install
}

#
# --- Tools functions ---
#

# Convert macaroon to HEX
macaroon_to_hex() {
	local macaroon="${1:-admin}"
	local macaroon="${macaroon%.*}"
	local path="${LND_DIR}/data/chain/bitcoin/mainnet/${macaroon}.macaroon"
	echo -e "‚ö°Ô∏è Convert ${CYAN}$macaroon${NC} macaroon to HEX"
	print_separator
	check_command xxd
	if [ ! -f "${path}" ]; then
		echo "No macaroon found at:"
		echo " --> ${path}"
	else
		xxd -ps -u -c 1000 "${path}"
	fi
	print_separator
}

# Generate strong passwords for Lit UI or Wallet. Prefer pwgen who
# include special characters
passwords_gen() {
	if [ -x /usr/bin/pwgen ] && [ "$1" != "openssl" ]; then
		wallet_pwd=$(pwgen -c -n -y -s 30 1)
		ui_pwd=$(pwgen -c -n -y -s 30 1)
	else
		wallet_pwd=$(openssl rand -hex 24 | tr -d "=+/")
		ui_pwd=$(openssl rand -hex 24 | tr -d "=+/")
	fi
}

# Change passwords for Lit UI and/or Wallet
passwords_change() {
	echo "‚ö°Ô∏è Change Passwords using: pwgen or openssl"
	print_separator
	echo ""
	passwords_gen ${2}
	echo "Wallet --> ${wallet_pwd}"
	echo "Lit UI --> ${ui_pwd}"
	echo ""
	echo -e "${CYAN}Write down your new password in a secure place!${NC}"
	echo ""
	
	read -p "Do you wish to change Wallet password ? (yes/no) " change
	if [ "$change" == "yes" ]; then
		echo "You can copy/paste it below."
		lncli changepassword
		# Update a wallet_password file ?
		if [ -f "$WALLET_PASS" ]; then
			echo "Updating: $WALLET_PASS"
			echo "${wallet_pwd}" > "${WALLET_PASS}"
			echo "Setting secure permissions: read only by $USER (0600)"
			chmod 0600 "${WALLET_PASS}"
		fi
	fi
	unset change && echo ""

	# lit.conf uipassword=
	if [ -f "$LIT_CONF" ]; then
		read -p "Do you wish to change Lit Web UI password ? (yes/no) " change
		if [ "$change" == "yes" ]; then
			echo "Updating: $LIT_CONF"
			sed -i s/"uipassword=.*"/"uipassword=${ui_pwd}"/ ${LIT_CONF}
			# Lit must reload to use the new password
			service_restart "restart" "litd"
			echo ""
			echo "Make sure your wallet is unlock to login with your new password."
		fi
	fi
	unset wallet_pwd ui_pwd
	echo "" && print_separator
}

# Handle passwords when initializing
password_init() {
	case "$1" in
		ui-password)
			passwords_gen "openssl"
			echo ""
			echo -e "${YELLOW}Lit UI pass -->${NC} ${ui_pwd}"
			echo ""
			echo "Write down or copy/past your UI password in a secure place."
			read -p "When your password is saved: press ENTER to continue"
			echo ""
			echo -e "${CYAN}Storing Lit UI password in:${NC} $LIT_CONF"
			sed -i s/"uipassword=.*"/"uipassword=${ui_pwd}"/ ${LIT_CONF}
			unset ui_pwd ;;
		wallet-password)
			passwords_gen "openssl"
			echo ""
			echo -e "${YELLOW}Wallet pass -->${NC} ${wallet_pwd}"
			echo ""
			echo "Write down or copy/past your Wallet password in a secure place."
			read -p "When your password is saved: press ENTER to continue"
			echo ""
			echo -e "${CYAN}Storing Wallet password in:${NC} $WALLET_PASS"
			echo "${wallet_pwd}" > "${WALLET_PASS}"
			echo "Setting secure permissions: read only by $USER (0600)"
			chmod 0600 "${WALLET_PASS}"
			echo "" ;;
	esac
}

# Check if a backup file was given
node_backup_check_path() {
	BACKUP_FILE="$1"
	if [ -z "$BACKUP_FILE" ]; then
		echo " ‚úò Missing backup file path: $(basename $0) $1 <file.gpg>"
		echo "" && exit 1
	fi
}

# Function to create a backup
node_backup() {

	check_command "gpg"
	echo "‚ö°Ô∏è Creating Node Backup"
	print_separator
	# Ensure backup directory exists
	echo " * Preparing backup directories..."
	mkdir -p "$BACKUP_DIR" "$TMP_BACKUP_DIR"

	echo " * Exporting Static Channel Backup (SCB)..."
	lncli exportchanbackup --all --output_file="$TMP_BACKUP_DIR/channel.backup"

	echo " * Copying LND files to backup directory..."
	cp -r "$LND_DIR" "$TMP_BACKUP_DIR/"

	echo " * Creating tarball archive..."
	TIMESTAMP=$(date +"%Y-%m-%d_%H-%M-%S")
	BACKUP_FILE="$BACKUP_DIR/lnd_backup_$TIMESTAMP.tar.gz"
	tar -czf "$BACKUP_FILE" -C "$TMP_BACKUP_DIR" .

	echo " * Cleaning up temporary files..."
	rm -rf "$TMP_BACKUP_DIR"

	echo " * Encrypting backup..."
	gpg --batch --yes --passphrase-file "$WALLET_PASS" -c "$BACKUP_FILE"
	rm -f "$BACKUP_FILE"
	echo " * Setting backup file permissions to: 0600 "
	chmod 0600 "$BACKUP_FILE"

	size=$(du -sh ${BACKUP_FILE}.gpg | cut -d "	" -f 1)
	echo -e " ‚úî Backup completed successfully: ${CYAN}${size}${NC}"
	echo -e "Encrypted backup: ${YELLOW}$(basename ${BACKUP_FILE}.gpg)${NC}"
	print_separator
}

# Function to restore a backup
node_backup_restore() {

	node_backup_check_path "$2"
	echo "‚ö°Ô∏è Restoring Node Backup"
	print_separator
	# Ensure backup directory exists
	echo " * Preparing to restore backup..."
	mkdir -p "$BACKUP_DIR" "$TMP_BACKUP_DIR"

	echo -e " * Decrypting: ${YELLOW}$(basename $BACKUP_FILE)${NC}"
	gpg --batch --yes --passphrase-file "$WALLET_PASS" \
		-o "$TMP_BACKUP_DIR/lnd_backup.tar.gz" -d "$BACKUP_FILE"

	echo " * Extracting backup..."
	tar -xzf "$TMP_BACKUP_DIR/lnd_backup.tar.gz" -C "$TMP_BACKUP_DIR"

	echo " * Restoring LND files..."
	cp -r "$TMP_BACKUP_DIR/.lnd" "$HOME/"

	echo " * Cleaning up temporary files..."
	rm -rf "$TMP_BACKUP_DIR"

	echo " ‚úî Restore completed. "
	echo -e "${CYAN}Restart LND/LiTd and unlock your wallet (if no auto-unlock).${NC}"
	print_separator
}

# Function to extract a backup for inspection
node_backup_extract() {

	node_backup_check_path "$2"
	echo "‚ö°Ô∏è Extracting Node Backup"
	print_separator
	# Ensure backup directory exists
	echo " * Preparing for extraction..."
	mkdir -p "$BACKUP_DIR" "$EXTRACTED_DIR"

	echo -e " * Decrypting: ${YELLOW}$(basename $BACKUP_FILE)${NC}"
	gpg --batch --yes --passphrase-file "$WALLET_PASS" \
		-o "$EXTRACTED_DIR/lnd_backup.tar.gz" -d "$BACKUP_FILE" || return 1

	echo " * Extracting backup contents for inspection..."
	tar -xzf "$EXTRACTED_DIR/lnd_backup.tar.gz" -C "$EXTRACTED_DIR"
	rm -f "$EXTRACTED_DIR/lnd_backup.tar.gz"

	echo " ‚úî Backup extracted in: $EXTRACTED_DIR/lnd_backup"
	echo -e "${CYAN}You can now inspect your files.${NC}"
	print_separator
}

# To be improved if/when LND is integrated
node_health() {
	check_command "jq"
	echo "‚ö°Ô∏è Node Health Check"
	print_separator
	echo "Service Status:"
	systemctl is-active litd >/dev/null 2>&1 && echo -e " --> litd: ${GREEN}Running${NC}" \
		|| echo " --> litd: ${RED}Stopped${NC}"
	echo -e "\nSync Status:"
	lncli getinfo | jq -r '" --> Synced: \(.synced_to_chain) | Block Height: \(.block_height)"'
	echo -en "\nConnected Peers: "
	lncli listpeers | jq -r '.peers | length' # | xargs echo " --> Peers:"
	# Open channel(s)
	echo -n "Channels Count: "
	lncli listchannels | jq -r '.channels[] | "\(.chan_id)"' | wc -l
	print_separator
}

#
# --- Packages Manager functions ---
#

# First check sli itself, then load a custom receip, check for
# a receipe in /usr/local/lib/sli (all packages install functions
# may/will... be in this path) and finaly use built-in function.
pkg_install() {
	if [ "$2" == "sli" ]; then
		echo "If you need to reinstall this version, run: sli init"
		echo "" && exit 0
	fi
	# We can install a package from a plugin recipe.sh file (providing
	# pkgname_install) from the curremt dir. Useful for development.
	if [ -f ${2}_recipe.sh ]; then
		source ${2}_recipe.sh
		${2}_install
		print_separator
		echo "" && exit 0
	fi
	# Let see if a package receip.sh is installed
	if [ -f /usr/local/lib/sli/${2}_recipe.sh ]; then
		source /usr/local/lib/sli/${2}_recipe.sh
		${2}_install
		print_separator
		echo "" && exit 0
	fi
	# Use built-in package
	if [ $(declare -F ${2}_install) ]; then
		${2}_install
		print_separator
	else
		echo "No package named: $2"
	fi 	
}

pkg_get_version() {
	grep "^${1}|" ${PKGS_LIST} | cut -d "|" -f 2
}

# Download pkg if needed
pkg_download_tarball() {
	if [ ! -f ${CACHE_DIR}/${TARBALL} ]; then
		echo "Downloading: $TARBALL"
		wget -q ${DL_URL} || { echo " ‚úò Error downloading: ${TARBALL}"; exit 1; }
	else
		echo "Using cache: ${TARBALL}"
	fi
}

# Ensure we extract in SRC_DIR
pkg_extract_tarball() {
	echo "Extracting: $TARBALL"
	mkdir -p ${SRC_DIR}
	case "$TARBALL" in
		*.tar.gz) tar xzf ${TARBALL} ;;
		"alby"*.tar.bz2) tar xjf ${TARBALL} -C ${SRC_DIR} ;; # -C for Alby
		*.tar.bz2) tar xjf ${TARBALL} ;;
		*.zip) unzip ${TARBALL} ;;
	esac
}

pkgs_get_list() {
	mkdir -p ${CACHE_DIR} && cd ${CACHE_DIR}
	echo "Fetching packages list from GitHub..."
	wget -q ${PKGS_URL} || exit 1
	mv -f packages.list ${SLI_DIR}
}

# Before install: called in pkg install function, ie lit_install
pkg_pre_install() {
	PKG_NAME="$1"
	PKG_VERSION="$2"
	PKG_DATA=${INSTALLED_PKGS}/${PKG_NAME}
	# Already installed ?
	if [ -f "${PKG_DATA}/pkg.conf" ]; then
		# Set version=
		source ${PKG_DATA}/pkg.conf
		# Upgrade or custom version ?
		if [ "$version" == "$PKG_VERSION" ]; then
			echo -e "${CYAN}$PKG_NAME is already installed${NC}"
			echo "Version: $version" && unset version
			echo "" && exit 0
		fi
	fi
	
	# We must handle packages conflict here. If lit is installed 
	# warn user: loop, pool will not work with litd, they need LND.
	case ${PKG_NAME} in
		loop|pool)
			if [ -d "${INSTALLED_PKGS}/lit" ]; then
				echo -e "The Lit package is installed and conflicts with: ${CYAN}${PKG_NAME}${NC}"
				echo "Lit is a bundle that provides loop, pool, lncli, and its own daemon, litd."
				echo "If you install $PKG_NAME, it will not work properly with litd."
				echo "You can either remove Lit or continue, and SLi will erase the $PKG_NAME Lit version."
				echo ""
				read -p "Continue installation anyway ? (yes/no) " answer
				[ "$answer" != "yes" ] && exit 0 
			fi ;;
		lnd)
			if [ -d "${INSTALLED_PKGS}/lit" ]; then
				echo -e "The Lit package is installed and conflicts with: ${CYAN}${PKG_NAME}${NC}"
				echo "Lit is a bundle that provides litd and lncli (LND command line interface)"
				echo "If you plan to use LND as your node daemon, you can always install LiT"
				echo "And then disable integrade mode, so you have LiT for UI and lnd as deamon"
				echo ""
				read -p "Continue installation anyway ? (yes/no) " answer
				[ "$answer" != "yes" ] && exit 0
			fi ;;
	esac
	
	echo "‚ö°Ô∏è Installing: $PKG_NAME $PKG_VERSION"
	print_separator
	# Continuing for install/upgrade - We work in SLi cache directory
	mkdir -p ${PKG_DATA} ${CACHE_DIR} && cd ${CACHE_DIR}
	# Keep track of previous installed files
	mv -f ${PKG_DATA}/files.list ${PKG_DATA}/files.list.old 2>/dev/null
}

# After install
pkg_post_install() {
	# Record version & clean cache
	echo "version=\"$PKG_VERSION\"" > ${PKG_DATA}/pkg.conf
	rm -rf ${SRC_DIR}
	log_action "Installed package: $PKG_NAME $PKG_VERSION"
	unset PKG_NAME SRC_URL PKG_VERSION TARBALL SRC_DIR DL_URL
}

pkgs_list() {
	echo "‚ö°Ô∏è Installed packages"
	print_separator
	[ -d "$INSTALLED_PKGS" ] || mkdir ${INSTALLED_PKGS}
	for pkg in $(ls ${INSTALLED_PKGS}); do
		source ${INSTALLED_PKGS}/${pkg}/pkg.conf
		echo "$pkg $version" | awk '{ printf "%-15s %-30s\n", $1, $2}'
		unset version
	done
	print_separator
	
	echo ""
	echo "‚ö°Ô∏è Available packages"
	print_separator
	# Ensure packages.list was downloaded
	[ -f "$PKGS_LIST" ] || pkgs_get_list
	for pkg in $(cat ${PKGS_LIST}); do
		name=$(echo $pkg | cut -d "|" -f 1)
		version=$(echo $pkg | cut -d "|" -f 2)
		echo "$name $version" | awk '{ printf "%-15s %-30s\n", $1, $2}'
	done
	print_separator
}

# Downlad a packages.list, compare installed version to the list
# upgrade everything
pkgs_upgrade() {
	echo "‚ö°Ô∏è Packages Upgrade"
	print_separator
	pkgs_get_list
	echo "Checking for packages update..."
	echo ""
	
	# Simply check if version differ and upgrade since packages.list is
	# maintained by OxeeLi GitHub repos it sould be fine.
	for pkg in $(ls $INSTALLED_PKGS); do
		source ${INSTALLED_PKGS}/${pkg}/pkg.conf
		available="$(grep "^${pkg}|" ${PKGS_LIST} | cut -d "|" -f 2)"
		if [ "$version" != "$available" ]; then
			echo -e "$pkg ${CYAN}$version${NC} --> ${GREEN}$available${NC}"
			# We want to upgrade SLi at first
			if [ "$pkg" == "sli" ]; then
				upgrades="$pkg $upgrades"
			else
				upgrades="$ugrades $pkg"
			fi
		fi
		unset version available
	done

	# Offer to upgarde all packages
	nb=$(echo ${upgrades} | wc -w)
	if [ "$nb" -gt "0" ]; then
		echo ""
		read -p "Do you wich to upgrade $nb packages ? (yes/no) " up
		if [ "$up" == "yes" ]; then
			echo ""
			for pkg in ${upgrades}; do
				if [ $(declare -F ${pkg}_install) ]; then
					${pkg}_install
				fi
			done
		fi
	else
		echo -e "${CYAN}Packages are up-to-date.${NC}"
	fi
}

# Remove system files keep config/data in ~/.*
pkg_remove() {
	pkg="$1"
	if [ ! -d ${INSTALLED_PKGS}/${pkg} ]; then
		echo -e " ‚úò Can't find package: ${RED}$pkg${NC}"
		echo "" && exit 1
	fi
	echo "‚ö°Ô∏è Removing package: $pkg"
	print_separator
	for file in $(cat ${INSTALLED_PKGS}/${pkg}/files.list); do
		echo " * Removing: $file"
		sudo rm -f ${file}
	done
	# Disable any enabled systemd boot symlink
	service_check "$pkg" "$pkg"
	if [ -L "/etc/systemd/system/multi-user.target.wants/${service}.service" ]; then
		echo " * Removing: systemd boot time unit symlink..."
		sudo systemctl disable ${service} 2>/dev/null # Be quit for nice SLi output
	fi
	rm -rf ${INSTALLED_PKGS}/${pkg}
	print_separator
}

# Handle channel commands
chan() {
	case "$2" in
		open) chan_open ;;
		close) chan_close ;;
		list) chan_list ;;
		*) chan_usage ;;
	esac
}

# Handle fees commands
fees() {
	case "$2" in
		check) fees_check "$3" ;;
		'set') fees_set ;;
		adjust) fees_adjust ;;
		bump) fees_bump ;;
		*) fees_usage ;;
	esac
}

# Handle Wallet commands
wallet() {
	case "$2" in
		init) wallet_init "--header" ;;
		logs) sli_logs ;;
		new) wallet_new_address ;;
		send) wallet_send_onchain ;;
		lsa|lsaddr|list-addresses) wallet_list_addresses ;;
		bal|balance) wallet_balance ;;
		inv|invoice) wallet_invoice ;;
		qri|qr-invoice) wallet_qr_invoice ;;
		rqr|remove-qr) wallet_remove_qr_invoice ;;
		pay|pay-invoice) wallet_pay_invoice ;;
		*) wallet_usage ;;
	esac
}

#
# --- Handle Top Level Commands ---
#

handle_command() {
	case "$1" in

		version|--version) sli_version ;;
		init)
			case "$2" in
				wallet) wallet_init "--header" ;;
				lit) lit_init ;;
				*) sli_init ;;
			esac ;;
		start) service_start ${@} ;;
		stop) service_stop ${@} ;;
		rs|restart) service_restart ${@} ;;
		sc|show-config) config_show ${2} ;;
		ed|edit) config_edit ${2} ;;
		lg|logs) 
			case "$2" in
				sli|wallet|node|packages) sli_logs ;;
				*) service_logs ${@} ;;
			esac ;;
		st|status) service_status ${@} ;;
		# --- Node ---
		nh|node-health) node_health ;;
		sign) sign_message ;;
		connect) peer_connect ;;
		chan) chan ${@} ;;
		fees) fees ${@} ;;
		# --- Tools ---
		m2h|macaroon-to-hex) macaroon_to_hex ${2} ;;
		gpw|gen-passwords) passwords_change ${@} ;;
		nb|node-backup) node_backup ;;
		nr|node-restore) node_backup_restore ${@} ;;
		ne|node-extract) node_backup_extract ${@} ;;
		sec|security-check) security_check ;;
		wa|wallet) wallet ${@} ;;
		# --- Packages manager ---
		'in'|install) pkg_install ${@} ;;
		ls|list) pkgs_list ;;
		up|upgrade) pkgs_upgrade ;;
		rm|remove) pkg_remove ${2} ;;
		cc|clean-cache)
			echo "Removing cache directory content..."
			rm -rf ${CACHE_DIR}/* ;;
		*) usage ;;
	esac
}

# Let's have default empty line for all actions
echo ""
handle_command ${@}
echo ""
exit 0
